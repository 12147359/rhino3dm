<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>rh3dm_temp.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Arc.html">Arc</a><ul class='methods'><li data-type='method'><a href="Arc.html#boundingBox">boundingBox</a></li><li data-type='method'><a href="Arc.html#closestPoint">closestPoint</a></li><li data-type='method'><a href="Arc.html#pointAt">pointAt</a></li><li data-type='method'><a href="Arc.html#reverse">reverse</a></li><li data-type='method'><a href="Arc.html#tangentAt">tangentAt</a></li><li data-type='method'><a href="Arc.html#toNurbsCurve">toNurbsCurve</a></li><li data-type='method'><a href="Arc.html#transform">transform</a></li><li data-type='method'><a href="Arc.html#trim">trim</a></li></ul></li><li><a href="ArcCurve.html">ArcCurve</a><ul class='methods'><li data-type='method'><a href="ArcCurve.html#changeClosedCurveSeam">changeClosedCurveSeam</a></li><li data-type='method'><a href="ArcCurve.html#changeDimension">changeDimension</a></li><li data-type='method'><a href="ArcCurve.html#curvatureAt">curvatureAt</a></li><li data-type='method'><a href="ArcCurve.html#encode">encode</a></li><li data-type='method'><a href="ArcCurve.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="ArcCurve.html#getUserString">getUserString</a></li><li data-type='method'><a href="ArcCurve.html#isArc">isArc</a></li><li data-type='method'><a href="ArcCurve.html#isCircle">isCircle</a></li><li data-type='method'><a href="ArcCurve.html#isEllipse">isEllipse</a></li><li data-type='method'><a href="ArcCurve.html#isLinear">isLinear</a></li><li data-type='method'><a href="ArcCurve.html#isPlanar">isPlanar</a></li><li data-type='method'><a href="ArcCurve.html#isPolyline">isPolyline</a></li><li data-type='method'><a href="ArcCurve.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="ArcCurve.html#pointAt">pointAt</a></li><li data-type='method'><a href="ArcCurve.html#reverse">reverse</a></li><li data-type='method'><a href="ArcCurve.html#rotate">rotate</a></li><li data-type='method'><a href="ArcCurve.html#scale">scale</a></li><li data-type='method'><a href="ArcCurve.html#setEndPoint">setEndPoint</a></li><li data-type='method'><a href="ArcCurve.html#setStartPoint">setStartPoint</a></li><li data-type='method'><a href="ArcCurve.html#setUserString">setUserString</a></li><li data-type='method'><a href="ArcCurve.html#tangentAt">tangentAt</a></li><li data-type='method'><a href="ArcCurve.html#toJSON">toJSON</a></li><li data-type='method'><a href="ArcCurve.html#toNurbsCurve">toNurbsCurve</a></li><li data-type='method'><a href="ArcCurve.html#transform">transform</a></li><li data-type='method'><a href="ArcCurve.html#translate">translate</a></li><li data-type='method'><a href="ArcCurve.html#trim">trim</a></li><li data-type='method'><a href="ArcCurve.html#tryGetArc">tryGetArc</a></li><li data-type='method'><a href="ArcCurve.html#tryGetCircle">tryGetCircle</a></li><li data-type='method'><a href="ArcCurve.html#tryGetPolyline">tryGetPolyline</a></li></ul></li><li><a href="BezierCurve.html">BezierCurve</a><ul class='methods'><li data-type='method'><a href="BezierCurve.html#changeDimension">changeDimension</a></li><li data-type='method'><a href="BezierCurve.html#curvatureAt">curvatureAt</a></li><li data-type='method'><a href="BezierCurve.html#increaseDegree">increaseDegree</a></li><li data-type='method'><a href="BezierCurve.html#makeNonRational">makeNonRational</a></li><li data-type='method'><a href="BezierCurve.html#makeRational">makeRational</a></li><li data-type='method'><a href="BezierCurve.html#pointAt">pointAt</a></li><li data-type='method'><a href="BezierCurve.html#tangentAt">tangentAt</a></li></ul></li><li><a href="Bitmap.html">Bitmap</a></li><li><a href="BoundingBox.html">BoundingBox</a><ul class='methods'><li data-type='method'><a href="BoundingBox.html#.decode">decode</a></li><li data-type='method'><a href="BoundingBox.html#.union">union</a></li><li data-type='method'><a href="BoundingBox.html#closestPoint">closestPoint</a></li><li data-type='method'><a href="BoundingBox.html#contains">contains</a></li><li data-type='method'><a href="BoundingBox.html#encode">encode</a></li><li data-type='method'><a href="BoundingBox.html#isDegenerate">isDegenerate</a></li><li data-type='method'><a href="BoundingBox.html#toBrep">toBrep</a></li><li data-type='method'><a href="BoundingBox.html#toJSON">toJSON</a></li><li data-type='method'><a href="BoundingBox.html#transform">transform</a></li></ul></li><li><a href="Box.html">Box</a><ul class='methods'><li data-type='method'><a href="Box.html#closestPoint">closestPoint</a></li><li data-type='method'><a href="Box.html#pointAt">pointAt</a></li><li data-type='method'><a href="Box.html#transform">transform</a></li></ul></li><li><a href="Brep.html">Brep</a><ul class='methods'><li data-type='method'><a href="Brep.html#encode">encode</a></li><li data-type='method'><a href="Brep.html#faces">faces</a></li><li data-type='method'><a href="Brep.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="Brep.html#getUserString">getUserString</a></li><li data-type='method'><a href="Brep.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="Brep.html#rotate">rotate</a></li><li data-type='method'><a href="Brep.html#scale">scale</a></li><li data-type='method'><a href="Brep.html#setUserString">setUserString</a></li><li data-type='method'><a href="Brep.html#toJSON">toJSON</a></li><li data-type='method'><a href="Brep.html#transform">transform</a></li><li data-type='method'><a href="Brep.html#translate">translate</a></li></ul></li><li><a href="BrepFace.html">BrepFace</a><ul class='methods'><li data-type='method'><a href="BrepFace.html#degree">degree</a></li><li data-type='method'><a href="BrepFace.html#encode">encode</a></li><li data-type='method'><a href="BrepFace.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="BrepFace.html#getMesh">getMesh</a></li><li data-type='method'><a href="BrepFace.html#getUserString">getUserString</a></li><li data-type='method'><a href="BrepFace.html#isAtSeam">isAtSeam</a></li><li data-type='method'><a href="BrepFace.html#isAtSingularity">isAtSingularity</a></li><li data-type='method'><a href="BrepFace.html#isClosed">isClosed</a></li><li data-type='method'><a href="BrepFace.html#isCone">isCone</a></li><li data-type='method'><a href="BrepFace.html#isCylinder">isCylinder</a></li><li data-type='method'><a href="BrepFace.html#isPeriodic">isPeriodic</a></li><li data-type='method'><a href="BrepFace.html#isPlanar">isPlanar</a></li><li data-type='method'><a href="BrepFace.html#isSingular">isSingular</a></li><li data-type='method'><a href="BrepFace.html#isSphere">isSphere</a></li><li data-type='method'><a href="BrepFace.html#isTorus">isTorus</a></li><li data-type='method'><a href="BrepFace.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="BrepFace.html#normalAt">normalAt</a></li><li data-type='method'><a href="BrepFace.html#pointAt">pointAt</a></li><li data-type='method'><a href="BrepFace.html#rotate">rotate</a></li><li data-type='method'><a href="BrepFace.html#scale">scale</a></li><li data-type='method'><a href="BrepFace.html#setUserString">setUserString</a></li><li data-type='method'><a href="BrepFace.html#spanCount">spanCount</a></li><li data-type='method'><a href="BrepFace.html#toJSON">toJSON</a></li><li data-type='method'><a href="BrepFace.html#transform">transform</a></li><li data-type='method'><a href="BrepFace.html#translate">translate</a></li></ul></li><li><a href="BrepFaceList.html">BrepFaceList</a><ul class='methods'><li data-type='method'><a href="BrepFaceList.html#get">get</a></li></ul></li><li><a href="Circle.html">Circle</a><ul class='methods'><li data-type='method'><a href="Circle.html#closestPoint">closestPoint</a></li><li data-type='method'><a href="Circle.html#derivativeAt">derivativeAt</a></li><li data-type='method'><a href="Circle.html#pointAt">pointAt</a></li><li data-type='method'><a href="Circle.html#reverse">reverse</a></li><li data-type='method'><a href="Circle.html#tangentAt">tangentAt</a></li><li data-type='method'><a href="Circle.html#toNurbsCurve">toNurbsCurve</a></li><li data-type='method'><a href="Circle.html#translate">translate</a></li></ul></li><li><a href="CommonObject.html">CommonObject</a><ul class='methods'><li data-type='method'><a href="CommonObject.html#.decode">decode</a></li><li data-type='method'><a href="CommonObject.html#encode">encode</a></li><li data-type='method'><a href="CommonObject.html#getUserString">getUserString</a></li><li data-type='method'><a href="CommonObject.html#setUserString">setUserString</a></li><li data-type='method'><a href="CommonObject.html#toJSON">toJSON</a></li></ul></li><li><a href="Cone.html">Cone</a><ul class='methods'><li data-type='method'><a href="Cone.html#toBrep">toBrep</a></li><li data-type='method'><a href="Cone.html#toNurbsSurface">toNurbsSurface</a></li></ul></li><li><a href="ConstructionPlane.html">ConstructionPlane</a></li><li><a href="Curve.html">Curve</a><ul class='methods'><li data-type='method'><a href="Curve.html#changeClosedCurveSeam">changeClosedCurveSeam</a></li><li data-type='method'><a href="Curve.html#changeDimension">changeDimension</a></li><li data-type='method'><a href="Curve.html#curvatureAt">curvatureAt</a></li><li data-type='method'><a href="Curve.html#encode">encode</a></li><li data-type='method'><a href="Curve.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="Curve.html#getUserString">getUserString</a></li><li data-type='method'><a href="Curve.html#isArc">isArc</a></li><li data-type='method'><a href="Curve.html#isCircle">isCircle</a></li><li data-type='method'><a href="Curve.html#isEllipse">isEllipse</a></li><li data-type='method'><a href="Curve.html#isLinear">isLinear</a></li><li data-type='method'><a href="Curve.html#isPlanar">isPlanar</a></li><li data-type='method'><a href="Curve.html#isPolyline">isPolyline</a></li><li data-type='method'><a href="Curve.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="Curve.html#pointAt">pointAt</a></li><li data-type='method'><a href="Curve.html#reverse">reverse</a></li><li data-type='method'><a href="Curve.html#rotate">rotate</a></li><li data-type='method'><a href="Curve.html#scale">scale</a></li><li data-type='method'><a href="Curve.html#setEndPoint">setEndPoint</a></li><li data-type='method'><a href="Curve.html#setStartPoint">setStartPoint</a></li><li data-type='method'><a href="Curve.html#setUserString">setUserString</a></li><li data-type='method'><a href="Curve.html#tangentAt">tangentAt</a></li><li data-type='method'><a href="Curve.html#toJSON">toJSON</a></li><li data-type='method'><a href="Curve.html#toNurbsCurve">toNurbsCurve</a></li><li data-type='method'><a href="Curve.html#transform">transform</a></li><li data-type='method'><a href="Curve.html#translate">translate</a></li><li data-type='method'><a href="Curve.html#trim">trim</a></li><li data-type='method'><a href="Curve.html#tryGetArc">tryGetArc</a></li><li data-type='method'><a href="Curve.html#tryGetCircle">tryGetCircle</a></li><li data-type='method'><a href="Curve.html#tryGetPolyline">tryGetPolyline</a></li></ul></li><li><a href="CurveProxy.html">CurveProxy</a><ul class='methods'><li data-type='method'><a href="CurveProxy.html#changeClosedCurveSeam">changeClosedCurveSeam</a></li><li data-type='method'><a href="CurveProxy.html#changeDimension">changeDimension</a></li><li data-type='method'><a href="CurveProxy.html#curvatureAt">curvatureAt</a></li><li data-type='method'><a href="CurveProxy.html#encode">encode</a></li><li data-type='method'><a href="CurveProxy.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="CurveProxy.html#getUserString">getUserString</a></li><li data-type='method'><a href="CurveProxy.html#isArc">isArc</a></li><li data-type='method'><a href="CurveProxy.html#isCircle">isCircle</a></li><li data-type='method'><a href="CurveProxy.html#isEllipse">isEllipse</a></li><li data-type='method'><a href="CurveProxy.html#isLinear">isLinear</a></li><li data-type='method'><a href="CurveProxy.html#isPlanar">isPlanar</a></li><li data-type='method'><a href="CurveProxy.html#isPolyline">isPolyline</a></li><li data-type='method'><a href="CurveProxy.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="CurveProxy.html#pointAt">pointAt</a></li><li data-type='method'><a href="CurveProxy.html#reverse">reverse</a></li><li data-type='method'><a href="CurveProxy.html#rotate">rotate</a></li><li data-type='method'><a href="CurveProxy.html#scale">scale</a></li><li data-type='method'><a href="CurveProxy.html#setEndPoint">setEndPoint</a></li><li data-type='method'><a href="CurveProxy.html#setStartPoint">setStartPoint</a></li><li data-type='method'><a href="CurveProxy.html#setUserString">setUserString</a></li><li data-type='method'><a href="CurveProxy.html#tangentAt">tangentAt</a></li><li data-type='method'><a href="CurveProxy.html#toJSON">toJSON</a></li><li data-type='method'><a href="CurveProxy.html#toNurbsCurve">toNurbsCurve</a></li><li data-type='method'><a href="CurveProxy.html#transform">transform</a></li><li data-type='method'><a href="CurveProxy.html#translate">translate</a></li><li data-type='method'><a href="CurveProxy.html#trim">trim</a></li><li data-type='method'><a href="CurveProxy.html#tryGetArc">tryGetArc</a></li><li data-type='method'><a href="CurveProxy.html#tryGetCircle">tryGetCircle</a></li><li data-type='method'><a href="CurveProxy.html#tryGetPolyline">tryGetPolyline</a></li></ul></li><li><a href="Cylinder.html">Cylinder</a><ul class='methods'><li data-type='method'><a href="Cylinder.html#circleAt">circleAt</a></li><li data-type='method'><a href="Cylinder.html#toBrep">toBrep</a></li><li data-type='method'><a href="Cylinder.html#toNurbsSurface">toNurbsSurface</a></li></ul></li><li><a href="Ellipse.html">Ellipse</a></li><li><a href="Extrusion.html">Extrusion</a><ul class='methods'><li data-type='method'><a href="Extrusion.html#.create">create</a></li><li data-type='method'><a href="Extrusion.html#.createCylinderExtrusion">createCylinderExtrusion</a></li><li data-type='method'><a href="Extrusion.html#.createPipeExtrusion">createPipeExtrusion</a></li><li data-type='method'><a href="Extrusion.html#degree">degree</a></li><li data-type='method'><a href="Extrusion.html#encode">encode</a></li><li data-type='method'><a href="Extrusion.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="Extrusion.html#getMesh">getMesh</a></li><li data-type='method'><a href="Extrusion.html#getUserString">getUserString</a></li><li data-type='method'><a href="Extrusion.html#isAtSeam">isAtSeam</a></li><li data-type='method'><a href="Extrusion.html#isAtSingularity">isAtSingularity</a></li><li data-type='method'><a href="Extrusion.html#isClosed">isClosed</a></li><li data-type='method'><a href="Extrusion.html#isCone">isCone</a></li><li data-type='method'><a href="Extrusion.html#isCylinder">isCylinder</a></li><li data-type='method'><a href="Extrusion.html#isPeriodic">isPeriodic</a></li><li data-type='method'><a href="Extrusion.html#isPlanar">isPlanar</a></li><li data-type='method'><a href="Extrusion.html#isSingular">isSingular</a></li><li data-type='method'><a href="Extrusion.html#isSphere">isSphere</a></li><li data-type='method'><a href="Extrusion.html#isTorus">isTorus</a></li><li data-type='method'><a href="Extrusion.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="Extrusion.html#normalAt">normalAt</a></li><li data-type='method'><a href="Extrusion.html#pointAt">pointAt</a></li><li data-type='method'><a href="Extrusion.html#rotate">rotate</a></li><li data-type='method'><a href="Extrusion.html#scale">scale</a></li><li data-type='method'><a href="Extrusion.html#setPathAndUp">setPathAndUp</a></li><li data-type='method'><a href="Extrusion.html#setUserString">setUserString</a></li><li data-type='method'><a href="Extrusion.html#spanCount">spanCount</a></li><li data-type='method'><a href="Extrusion.html#toBrep">toBrep</a></li><li data-type='method'><a href="Extrusion.html#toJSON">toJSON</a></li><li data-type='method'><a href="Extrusion.html#transform">transform</a></li><li data-type='method'><a href="Extrusion.html#translate">translate</a></li></ul></li><li><a href="File3dm.html">File3dm</a><ul class='methods'><li data-type='method'><a href="File3dm.html#.fromByteArray">fromByteArray</a></li><li data-type='method'><a href="File3dm.html#layers">layers</a></li><li data-type='method'><a href="File3dm.html#objects">objects</a></li></ul></li><li><a href="File3dmLayerTable.html">File3dmLayerTable</a><ul class='methods'><li data-type='method'><a href="File3dmLayerTable.html#add">add</a></li><li data-type='method'><a href="File3dmLayerTable.html#count">count</a></li><li data-type='method'><a href="File3dmLayerTable.html#findId">findId</a></li><li data-type='method'><a href="File3dmLayerTable.html#findIndex">findIndex</a></li><li data-type='method'><a href="File3dmLayerTable.html#findName">findName</a></li><li data-type='method'><a href="File3dmLayerTable.html#get">get</a></li></ul></li><li><a href="File3dmObject.html">File3dmObject</a><ul class='methods'><li data-type='method'><a href="File3dmObject.html#attributes">attributes</a></li><li data-type='method'><a href="File3dmObject.html#geometry">geometry</a></li></ul></li><li><a href="File3dmObjectTable.html">File3dmObjectTable</a><ul class='methods'><li data-type='method'><a href="File3dmObjectTable.html#addBrep">addBrep</a></li><li data-type='method'><a href="File3dmObjectTable.html#addCircle">addCircle</a></li><li data-type='method'><a href="File3dmObjectTable.html#addCurve">addCurve</a></li><li data-type='method'><a href="File3dmObjectTable.html#addLine">addLine</a></li><li data-type='method'><a href="File3dmObjectTable.html#addMesh">addMesh</a></li><li data-type='method'><a href="File3dmObjectTable.html#addPoint">addPoint</a></li><li data-type='method'><a href="File3dmObjectTable.html#addSphere">addSphere</a></li><li data-type='method'><a href="File3dmObjectTable.html#addTextDot">addTextDot</a></li><li data-type='method'><a href="File3dmObjectTable.html#get">get</a></li><li data-type='method'><a href="File3dmObjectTable.html#getBoundingBox">getBoundingBox</a></li></ul></li><li><a href="FileReference.html">FileReference</a><ul class='methods'><li data-type='method'><a href="FileReference.html#.createFromFullAndRelativePaths">createFromFullAndRelativePaths</a></li><li data-type='method'><a href="FileReference.html#.createFromFullPath">createFromFullPath</a></li></ul></li><li><a href="GeometryBase.html">GeometryBase</a><ul class='methods'><li data-type='method'><a href="GeometryBase.html#encode">encode</a></li><li data-type='method'><a href="GeometryBase.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="GeometryBase.html#getUserString">getUserString</a></li><li data-type='method'><a href="GeometryBase.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="GeometryBase.html#rotate">rotate</a></li><li data-type='method'><a href="GeometryBase.html#scale">scale</a></li><li data-type='method'><a href="GeometryBase.html#setUserString">setUserString</a></li><li data-type='method'><a href="GeometryBase.html#toJSON">toJSON</a></li><li data-type='method'><a href="GeometryBase.html#transform">transform</a></li><li data-type='method'><a href="GeometryBase.html#translate">translate</a></li></ul></li><li><a href="Hatch.html">Hatch</a><ul class='methods'><li data-type='method'><a href="Hatch.html#encode">encode</a></li><li data-type='method'><a href="Hatch.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="Hatch.html#getUserString">getUserString</a></li><li data-type='method'><a href="Hatch.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="Hatch.html#rotate">rotate</a></li><li data-type='method'><a href="Hatch.html#scale">scale</a></li><li data-type='method'><a href="Hatch.html#setUserString">setUserString</a></li><li data-type='method'><a href="Hatch.html#toJSON">toJSON</a></li><li data-type='method'><a href="Hatch.html#transform">transform</a></li><li data-type='method'><a href="Hatch.html#translate">translate</a></li></ul></li><li><a href="Layer.html">Layer</a><ul class='methods'><li data-type='method'><a href="Layer.html#deletePerViewportColor">deletePerViewportColor</a></li><li data-type='method'><a href="Layer.html#deletePerViewportSettings">deletePerViewportSettings</a></li><li data-type='method'><a href="Layer.html#encode">encode</a></li><li data-type='method'><a href="Layer.html#getPersistentLocking">getPersistentLocking</a></li><li data-type='method'><a href="Layer.html#getPersistentVisibility">getPersistentVisibility</a></li><li data-type='method'><a href="Layer.html#getUserString">getUserString</a></li><li data-type='method'><a href="Layer.html#hasPerViewportSettings">hasPerViewportSettings</a></li><li data-type='method'><a href="Layer.html#perViewportColor">perViewportColor</a></li><li data-type='method'><a href="Layer.html#setPersistentLocking">setPersistentLocking</a></li><li data-type='method'><a href="Layer.html#setPersistentVisibility">setPersistentVisibility</a></li><li data-type='method'><a href="Layer.html#setPerViewportColor">setPerViewportColor</a></li><li data-type='method'><a href="Layer.html#setUserString">setUserString</a></li><li data-type='method'><a href="Layer.html#toJSON">toJSON</a></li><li data-type='method'><a href="Layer.html#unsetPersistentLocking">unsetPersistentLocking</a></li><li data-type='method'><a href="Layer.html#unsetPersistentVisibility">unsetPersistentVisibility</a></li></ul></li><li><a href="Line.html">Line</a></li><li><a href="LineCurve.html">LineCurve</a><ul class='methods'><li data-type='method'><a href="LineCurve.html#changeClosedCurveSeam">changeClosedCurveSeam</a></li><li data-type='method'><a href="LineCurve.html#changeDimension">changeDimension</a></li><li data-type='method'><a href="LineCurve.html#curvatureAt">curvatureAt</a></li><li data-type='method'><a href="LineCurve.html#encode">encode</a></li><li data-type='method'><a href="LineCurve.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="LineCurve.html#getUserString">getUserString</a></li><li data-type='method'><a href="LineCurve.html#isArc">isArc</a></li><li data-type='method'><a href="LineCurve.html#isCircle">isCircle</a></li><li data-type='method'><a href="LineCurve.html#isEllipse">isEllipse</a></li><li data-type='method'><a href="LineCurve.html#isLinear">isLinear</a></li><li data-type='method'><a href="LineCurve.html#isPlanar">isPlanar</a></li><li data-type='method'><a href="LineCurve.html#isPolyline">isPolyline</a></li><li data-type='method'><a href="LineCurve.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="LineCurve.html#pointAt">pointAt</a></li><li data-type='method'><a href="LineCurve.html#reverse">reverse</a></li><li data-type='method'><a href="LineCurve.html#rotate">rotate</a></li><li data-type='method'><a href="LineCurve.html#scale">scale</a></li><li data-type='method'><a href="LineCurve.html#setEndPoint">setEndPoint</a></li><li data-type='method'><a href="LineCurve.html#setStartPoint">setStartPoint</a></li><li data-type='method'><a href="LineCurve.html#setUserString">setUserString</a></li><li data-type='method'><a href="LineCurve.html#tangentAt">tangentAt</a></li><li data-type='method'><a href="LineCurve.html#toJSON">toJSON</a></li><li data-type='method'><a href="LineCurve.html#toNurbsCurve">toNurbsCurve</a></li><li data-type='method'><a href="LineCurve.html#transform">transform</a></li><li data-type='method'><a href="LineCurve.html#translate">translate</a></li><li data-type='method'><a href="LineCurve.html#trim">trim</a></li><li data-type='method'><a href="LineCurve.html#tryGetArc">tryGetArc</a></li><li data-type='method'><a href="LineCurve.html#tryGetCircle">tryGetCircle</a></li><li data-type='method'><a href="LineCurve.html#tryGetPolyline">tryGetPolyline</a></li></ul></li><li><a href="Material.html">Material</a><ul class='methods'><li data-type='method'><a href="Material.html#default">default</a></li><li data-type='method'><a href="Material.html#encode">encode</a></li><li data-type='method'><a href="Material.html#getBitmapTexture">getBitmapTexture</a></li><li data-type='method'><a href="Material.html#getBumpTexture">getBumpTexture</a></li><li data-type='method'><a href="Material.html#getEnvironmentTexture">getEnvironmentTexture</a></li><li data-type='method'><a href="Material.html#getTransparencyTexture">getTransparencyTexture</a></li><li data-type='method'><a href="Material.html#getUserString">getUserString</a></li><li data-type='method'><a href="Material.html#setBitmapTexture">setBitmapTexture</a></li><li data-type='method'><a href="Material.html#setBumpTexture">setBumpTexture</a></li><li data-type='method'><a href="Material.html#setEnvironmentTexture">setEnvironmentTexture</a></li><li data-type='method'><a href="Material.html#setTransparencyTexture">setTransparencyTexture</a></li><li data-type='method'><a href="Material.html#setUserString">setUserString</a></li><li data-type='method'><a href="Material.html#toJSON">toJSON</a></li></ul></li><li><a href="Mesh.html">Mesh</a><ul class='methods'><li data-type='method'><a href="Mesh.html#append">append</a></li><li data-type='method'><a href="Mesh.html#clearSurfaceData">clearSurfaceData</a></li><li data-type='method'><a href="Mesh.html#clearTextureData">clearTextureData</a></li><li data-type='method'><a href="Mesh.html#compact">compact</a></li><li data-type='method'><a href="Mesh.html#createPartitions">createPartitions</a></li><li data-type='method'><a href="Mesh.html#destroyPartition">destroyPartition</a></li><li data-type='method'><a href="Mesh.html#destroyTopology">destroyTopology</a></li><li data-type='method'><a href="Mesh.html#destroyTree">destroyTree</a></li><li data-type='method'><a href="Mesh.html#encode">encode</a></li><li data-type='method'><a href="Mesh.html#faces">faces</a></li><li data-type='method'><a href="Mesh.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="Mesh.html#getUserString">getUserString</a></li><li data-type='method'><a href="Mesh.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="Mesh.html#normals">normals</a></li><li data-type='method'><a href="Mesh.html#rotate">rotate</a></li><li data-type='method'><a href="Mesh.html#scale">scale</a></li><li data-type='method'><a href="Mesh.html#setUserString">setUserString</a></li><li data-type='method'><a href="Mesh.html#textureCoordinates">textureCoordinates</a></li><li data-type='method'><a href="Mesh.html#toJSON">toJSON</a></li><li data-type='method'><a href="Mesh.html#transform">transform</a></li><li data-type='method'><a href="Mesh.html#translate">translate</a></li><li data-type='method'><a href="Mesh.html#vertices">vertices</a></li></ul></li><li><a href="MeshFaceList.html">MeshFaceList</a><ul class='methods'><li data-type='method'><a href="MeshFaceList.html#get">get</a></li></ul></li><li><a href="MeshNormalList.html">MeshNormalList</a><ul class='methods'><li data-type='method'><a href="MeshNormalList.html#get">get</a></li><li data-type='method'><a href="MeshNormalList.html#set">set</a></li></ul></li><li><a href="MeshTextureCoordinateList.html">MeshTextureCoordinateList</a><ul class='methods'><li data-type='method'><a href="MeshTextureCoordinateList.html#get">get</a></li><li data-type='method'><a href="MeshTextureCoordinateList.html#set">set</a></li></ul></li><li><a href="MeshVertexList.html">MeshVertexList</a><ul class='methods'><li data-type='method'><a href="MeshVertexList.html#get">get</a></li><li data-type='method'><a href="MeshVertexList.html#set">set</a></li><li data-type='method'><a href="MeshVertexList.html#setCount">setCount</a></li></ul></li><li><a href="ModelComponent.html">ModelComponent</a><ul class='methods'><li data-type='method'><a href="ModelComponent.html#encode">encode</a></li><li data-type='method'><a href="ModelComponent.html#getUserString">getUserString</a></li><li data-type='method'><a href="ModelComponent.html#setUserString">setUserString</a></li><li data-type='method'><a href="ModelComponent.html#toJSON">toJSON</a></li></ul></li><li><a href="NurbsCurve.html">NurbsCurve</a><ul class='methods'><li data-type='method'><a href="NurbsCurve.html#.create">create</a></li><li data-type='method'><a href="NurbsCurve.html#.createFromArc">createFromArc</a></li><li data-type='method'><a href="NurbsCurve.html#.createFromCircle">createFromCircle</a></li><li data-type='method'><a href="NurbsCurve.html#.createFromEllipse">createFromEllipse</a></li><li data-type='method'><a href="NurbsCurve.html#.createFromLine">createFromLine</a></li><li data-type='method'><a href="NurbsCurve.html#changeClosedCurveSeam">changeClosedCurveSeam</a></li><li data-type='method'><a href="NurbsCurve.html#changeDimension">changeDimension</a></li><li data-type='method'><a href="NurbsCurve.html#curvatureAt">curvatureAt</a></li><li data-type='method'><a href="NurbsCurve.html#encode">encode</a></li><li data-type='method'><a href="NurbsCurve.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="NurbsCurve.html#getUserString">getUserString</a></li><li data-type='method'><a href="NurbsCurve.html#grevilleParameter">grevilleParameter</a></li><li data-type='method'><a href="NurbsCurve.html#grevillePoint">grevillePoint</a></li><li data-type='method'><a href="NurbsCurve.html#increaseDegree">increaseDegree</a></li><li data-type='method'><a href="NurbsCurve.html#isArc">isArc</a></li><li data-type='method'><a href="NurbsCurve.html#isCircle">isCircle</a></li><li data-type='method'><a href="NurbsCurve.html#isEllipse">isEllipse</a></li><li data-type='method'><a href="NurbsCurve.html#isLinear">isLinear</a></li><li data-type='method'><a href="NurbsCurve.html#isPlanar">isPlanar</a></li><li data-type='method'><a href="NurbsCurve.html#isPolyline">isPolyline</a></li><li data-type='method'><a href="NurbsCurve.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="NurbsCurve.html#makePiecewiseBezier">makePiecewiseBezier</a></li><li data-type='method'><a href="NurbsCurve.html#pointAt">pointAt</a></li><li data-type='method'><a href="NurbsCurve.html#reparameterize">reparameterize</a></li><li data-type='method'><a href="NurbsCurve.html#reverse">reverse</a></li><li data-type='method'><a href="NurbsCurve.html#rotate">rotate</a></li><li data-type='method'><a href="NurbsCurve.html#scale">scale</a></li><li data-type='method'><a href="NurbsCurve.html#setEndPoint">setEndPoint</a></li><li data-type='method'><a href="NurbsCurve.html#setStartPoint">setStartPoint</a></li><li data-type='method'><a href="NurbsCurve.html#setUserString">setUserString</a></li><li data-type='method'><a href="NurbsCurve.html#tangentAt">tangentAt</a></li><li data-type='method'><a href="NurbsCurve.html#toJSON">toJSON</a></li><li data-type='method'><a href="NurbsCurve.html#toNurbsCurve">toNurbsCurve</a></li><li data-type='method'><a href="NurbsCurve.html#transform">transform</a></li><li data-type='method'><a href="NurbsCurve.html#translate">translate</a></li><li data-type='method'><a href="NurbsCurve.html#trim">trim</a></li><li data-type='method'><a href="NurbsCurve.html#tryGetArc">tryGetArc</a></li><li data-type='method'><a href="NurbsCurve.html#tryGetCircle">tryGetCircle</a></li><li data-type='method'><a href="NurbsCurve.html#tryGetPolyline">tryGetPolyline</a></li></ul></li><li><a href="NurbsCurveKnotList.html">NurbsCurveKnotList</a><ul class='methods'><li data-type='method'><a href="NurbsCurveKnotList.html#createPeriodicKnots">createPeriodicKnots</a></li><li data-type='method'><a href="NurbsCurveKnotList.html#createUniformKnots">createUniformKnots</a></li><li data-type='method'><a href="NurbsCurveKnotList.html#get">get</a></li><li data-type='method'><a href="NurbsCurveKnotList.html#insertKnot">insertKnot</a></li><li data-type='method'><a href="NurbsCurveKnotList.html#knotMultiplicity">knotMultiplicity</a></li><li data-type='method'><a href="NurbsCurveKnotList.html#set">set</a></li><li data-type='method'><a href="NurbsCurveKnotList.html#superfluousKnot">superfluousKnot</a></li></ul></li><li><a href="NurbsCurvePointList.html">NurbsCurvePointList</a><ul class='methods'><li data-type='method'><a href="NurbsCurvePointList.html#changeEndWeights">changeEndWeights</a></li><li data-type='method'><a href="NurbsCurvePointList.html#get">get</a></li><li data-type='method'><a href="NurbsCurvePointList.html#makeNonRational">makeNonRational</a></li><li data-type='method'><a href="NurbsCurvePointList.html#makeRational">makeRational</a></li><li data-type='method'><a href="NurbsCurvePointList.html#set">set</a></li></ul></li><li><a href="NurbsSurface.html">NurbsSurface</a><ul class='methods'><li data-type='method'><a href="NurbsSurface.html#.createRuledSurface">createRuledSurface</a></li><li data-type='method'><a href="NurbsSurface.html#degree">degree</a></li><li data-type='method'><a href="NurbsSurface.html#encode">encode</a></li><li data-type='method'><a href="NurbsSurface.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="NurbsSurface.html#getUserString">getUserString</a></li><li data-type='method'><a href="NurbsSurface.html#increaseDegreeU">increaseDegreeU</a></li><li data-type='method'><a href="NurbsSurface.html#increaseDegreeV">increaseDegreeV</a></li><li data-type='method'><a href="NurbsSurface.html#isAtSeam">isAtSeam</a></li><li data-type='method'><a href="NurbsSurface.html#isAtSingularity">isAtSingularity</a></li><li data-type='method'><a href="NurbsSurface.html#isClosed">isClosed</a></li><li data-type='method'><a href="NurbsSurface.html#isCone">isCone</a></li><li data-type='method'><a href="NurbsSurface.html#isCylinder">isCylinder</a></li><li data-type='method'><a href="NurbsSurface.html#isPeriodic">isPeriodic</a></li><li data-type='method'><a href="NurbsSurface.html#isPlanar">isPlanar</a></li><li data-type='method'><a href="NurbsSurface.html#isSingular">isSingular</a></li><li data-type='method'><a href="NurbsSurface.html#isSphere">isSphere</a></li><li data-type='method'><a href="NurbsSurface.html#isTorus">isTorus</a></li><li data-type='method'><a href="NurbsSurface.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="NurbsSurface.html#makeNonRational">makeNonRational</a></li><li data-type='method'><a href="NurbsSurface.html#makeRational">makeRational</a></li><li data-type='method'><a href="NurbsSurface.html#normalAt">normalAt</a></li><li data-type='method'><a href="NurbsSurface.html#pointAt">pointAt</a></li><li data-type='method'><a href="NurbsSurface.html#rotate">rotate</a></li><li data-type='method'><a href="NurbsSurface.html#scale">scale</a></li><li data-type='method'><a href="NurbsSurface.html#setUserString">setUserString</a></li><li data-type='method'><a href="NurbsSurface.html#spanCount">spanCount</a></li><li data-type='method'><a href="NurbsSurface.html#toJSON">toJSON</a></li><li data-type='method'><a href="NurbsSurface.html#transform">transform</a></li><li data-type='method'><a href="NurbsSurface.html#translate">translate</a></li></ul></li><li><a href="ObjectAttributes.html">ObjectAttributes</a><ul class='methods'><li data-type='method'><a href="ObjectAttributes.html#addToGroup">addToGroup</a></li><li data-type='method'><a href="ObjectAttributes.html#encode">encode</a></li><li data-type='method'><a href="ObjectAttributes.html#getUserString">getUserString</a></li><li data-type='method'><a href="ObjectAttributes.html#hasDisplayModeOverride">hasDisplayModeOverride</a></li><li data-type='method'><a href="ObjectAttributes.html#removeFromAllGroups">removeFromAllGroups</a></li><li data-type='method'><a href="ObjectAttributes.html#removeFromGroup">removeFromGroup</a></li><li data-type='method'><a href="ObjectAttributes.html#setUserString">setUserString</a></li><li data-type='method'><a href="ObjectAttributes.html#toJSON">toJSON</a></li><li data-type='method'><a href="ObjectAttributes.html#transform">transform</a></li></ul></li><li><a href="PlaneSurface.html">PlaneSurface</a><ul class='methods'><li data-type='method'><a href="PlaneSurface.html#degree">degree</a></li><li data-type='method'><a href="PlaneSurface.html#encode">encode</a></li><li data-type='method'><a href="PlaneSurface.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="PlaneSurface.html#getUserString">getUserString</a></li><li data-type='method'><a href="PlaneSurface.html#isAtSeam">isAtSeam</a></li><li data-type='method'><a href="PlaneSurface.html#isAtSingularity">isAtSingularity</a></li><li data-type='method'><a href="PlaneSurface.html#isClosed">isClosed</a></li><li data-type='method'><a href="PlaneSurface.html#isCone">isCone</a></li><li data-type='method'><a href="PlaneSurface.html#isCylinder">isCylinder</a></li><li data-type='method'><a href="PlaneSurface.html#isPeriodic">isPeriodic</a></li><li data-type='method'><a href="PlaneSurface.html#isPlanar">isPlanar</a></li><li data-type='method'><a href="PlaneSurface.html#isSingular">isSingular</a></li><li data-type='method'><a href="PlaneSurface.html#isSphere">isSphere</a></li><li data-type='method'><a href="PlaneSurface.html#isTorus">isTorus</a></li><li data-type='method'><a href="PlaneSurface.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="PlaneSurface.html#normalAt">normalAt</a></li><li data-type='method'><a href="PlaneSurface.html#pointAt">pointAt</a></li><li data-type='method'><a href="PlaneSurface.html#rotate">rotate</a></li><li data-type='method'><a href="PlaneSurface.html#scale">scale</a></li><li data-type='method'><a href="PlaneSurface.html#setUserString">setUserString</a></li><li data-type='method'><a href="PlaneSurface.html#spanCount">spanCount</a></li><li data-type='method'><a href="PlaneSurface.html#toJSON">toJSON</a></li><li data-type='method'><a href="PlaneSurface.html#transform">transform</a></li><li data-type='method'><a href="PlaneSurface.html#translate">translate</a></li></ul></li><li><a href="Point.html">Point</a><ul class='methods'><li data-type='method'><a href="Point.html#encode">encode</a></li><li data-type='method'><a href="Point.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="Point.html#getUserString">getUserString</a></li><li data-type='method'><a href="Point.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="Point.html#rotate">rotate</a></li><li data-type='method'><a href="Point.html#scale">scale</a></li><li data-type='method'><a href="Point.html#setUserString">setUserString</a></li><li data-type='method'><a href="Point.html#toJSON">toJSON</a></li><li data-type='method'><a href="Point.html#transform">transform</a></li><li data-type='method'><a href="Point.html#translate">translate</a></li></ul></li><li><a href="Point3d.html">Point3d</a><ul class='methods'><li data-type='method'><a href="Point3d.html#.transform">transform</a></li></ul></li><li><a href="Point3dList.html">Point3dList</a><ul class='methods'><li data-type='method'><a href="Point3dList.html#add">add</a></li><li data-type='method'><a href="Point3dList.html#clear">clear</a></li><li data-type='method'><a href="Point3dList.html#get">get</a></li><li data-type='method'><a href="Point3dList.html#insert">insert</a></li><li data-type='method'><a href="Point3dList.html#removeAt">removeAt</a></li><li data-type='method'><a href="Point3dList.html#set">set</a></li><li data-type='method'><a href="Point3dList.html#setAllX">setAllX</a></li><li data-type='method'><a href="Point3dList.html#setAllY">setAllY</a></li><li data-type='method'><a href="Point3dList.html#setAllZ">setAllZ</a></li><li data-type='method'><a href="Point3dList.html#transform">transform</a></li></ul></li><li><a href="PointCloud.html">PointCloud</a><ul class='methods'><li data-type='method'><a href="PointCloud.html#encode">encode</a></li><li data-type='method'><a href="PointCloud.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="PointCloud.html#getUserString">getUserString</a></li><li data-type='method'><a href="PointCloud.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="PointCloud.html#rotate">rotate</a></li><li data-type='method'><a href="PointCloud.html#scale">scale</a></li><li data-type='method'><a href="PointCloud.html#setUserString">setUserString</a></li><li data-type='method'><a href="PointCloud.html#toJSON">toJSON</a></li><li data-type='method'><a href="PointCloud.html#transform">transform</a></li><li data-type='method'><a href="PointCloud.html#translate">translate</a></li></ul></li><li><a href="PointGrid.html">PointGrid</a><ul class='methods'><li data-type='method'><a href="PointGrid.html#encode">encode</a></li><li data-type='method'><a href="PointGrid.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="PointGrid.html#getUserString">getUserString</a></li><li data-type='method'><a href="PointGrid.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="PointGrid.html#rotate">rotate</a></li><li data-type='method'><a href="PointGrid.html#scale">scale</a></li><li data-type='method'><a href="PointGrid.html#setUserString">setUserString</a></li><li data-type='method'><a href="PointGrid.html#toJSON">toJSON</a></li><li data-type='method'><a href="PointGrid.html#transform">transform</a></li><li data-type='method'><a href="PointGrid.html#translate">translate</a></li></ul></li><li><a href="Polycurve.html">Polycurve</a><ul class='methods'><li data-type='method'><a href="Polycurve.html#changeClosedCurveSeam">changeClosedCurveSeam</a></li><li data-type='method'><a href="Polycurve.html#changeDimension">changeDimension</a></li><li data-type='method'><a href="Polycurve.html#curvatureAt">curvatureAt</a></li><li data-type='method'><a href="Polycurve.html#encode">encode</a></li><li data-type='method'><a href="Polycurve.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="Polycurve.html#getUserString">getUserString</a></li><li data-type='method'><a href="Polycurve.html#isArc">isArc</a></li><li data-type='method'><a href="Polycurve.html#isCircle">isCircle</a></li><li data-type='method'><a href="Polycurve.html#isEllipse">isEllipse</a></li><li data-type='method'><a href="Polycurve.html#isLinear">isLinear</a></li><li data-type='method'><a href="Polycurve.html#isPlanar">isPlanar</a></li><li data-type='method'><a href="Polycurve.html#isPolyline">isPolyline</a></li><li data-type='method'><a href="Polycurve.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="Polycurve.html#pointAt">pointAt</a></li><li data-type='method'><a href="Polycurve.html#reverse">reverse</a></li><li data-type='method'><a href="Polycurve.html#rotate">rotate</a></li><li data-type='method'><a href="Polycurve.html#scale">scale</a></li><li data-type='method'><a href="Polycurve.html#setEndPoint">setEndPoint</a></li><li data-type='method'><a href="Polycurve.html#setStartPoint">setStartPoint</a></li><li data-type='method'><a href="Polycurve.html#setUserString">setUserString</a></li><li data-type='method'><a href="Polycurve.html#tangentAt">tangentAt</a></li><li data-type='method'><a href="Polycurve.html#toJSON">toJSON</a></li><li data-type='method'><a href="Polycurve.html#toNurbsCurve">toNurbsCurve</a></li><li data-type='method'><a href="Polycurve.html#transform">transform</a></li><li data-type='method'><a href="Polycurve.html#translate">translate</a></li><li data-type='method'><a href="Polycurve.html#trim">trim</a></li><li data-type='method'><a href="Polycurve.html#tryGetArc">tryGetArc</a></li><li data-type='method'><a href="Polycurve.html#tryGetCircle">tryGetCircle</a></li><li data-type='method'><a href="Polycurve.html#tryGetPolyline">tryGetPolyline</a></li></ul></li><li><a href="Polyline.html">Polyline</a><ul class='methods'><li data-type='method'><a href="Polyline.html#.createCircumscribedPolygon">createCircumscribedPolygon</a></li><li data-type='method'><a href="Polyline.html#.createInscribedPolygon">createInscribedPolygon</a></li><li data-type='method'><a href="Polyline.html#.createStarPolygon">createStarPolygon</a></li><li data-type='method'><a href="Polyline.html#add">add</a></li><li data-type='method'><a href="Polyline.html#clear">clear</a></li><li data-type='method'><a href="Polyline.html#closesPoint">closesPoint</a></li><li data-type='method'><a href="Polyline.html#closestParameter">closestParameter</a></li><li data-type='method'><a href="Polyline.html#get">get</a></li><li data-type='method'><a href="Polyline.html#insert">insert</a></li><li data-type='method'><a href="Polyline.html#isClosedWithinTolerance">isClosedWithinTolerance</a></li><li data-type='method'><a href="Polyline.html#pointAt">pointAt</a></li><li data-type='method'><a href="Polyline.html#removeAt">removeAt</a></li><li data-type='method'><a href="Polyline.html#set">set</a></li><li data-type='method'><a href="Polyline.html#setAllX">setAllX</a></li><li data-type='method'><a href="Polyline.html#setAllY">setAllY</a></li><li data-type='method'><a href="Polyline.html#setAllZ">setAllZ</a></li><li data-type='method'><a href="Polyline.html#tangentAt">tangentAt</a></li><li data-type='method'><a href="Polyline.html#toNurbsCurve">toNurbsCurve</a></li><li data-type='method'><a href="Polyline.html#toPolylineCurve">toPolylineCurve</a></li><li data-type='method'><a href="Polyline.html#transform">transform</a></li></ul></li><li><a href="Polylinecurve.html">Polylinecurve</a><ul class='methods'><li data-type='method'><a href="Polylinecurve.html#changeClosedCurveSeam">changeClosedCurveSeam</a></li><li data-type='method'><a href="Polylinecurve.html#changeDimension">changeDimension</a></li><li data-type='method'><a href="Polylinecurve.html#curvatureAt">curvatureAt</a></li><li data-type='method'><a href="Polylinecurve.html#encode">encode</a></li><li data-type='method'><a href="Polylinecurve.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="Polylinecurve.html#getUserString">getUserString</a></li><li data-type='method'><a href="Polylinecurve.html#isArc">isArc</a></li><li data-type='method'><a href="Polylinecurve.html#isCircle">isCircle</a></li><li data-type='method'><a href="Polylinecurve.html#isEllipse">isEllipse</a></li><li data-type='method'><a href="Polylinecurve.html#isLinear">isLinear</a></li><li data-type='method'><a href="Polylinecurve.html#isPlanar">isPlanar</a></li><li data-type='method'><a href="Polylinecurve.html#isPolyline">isPolyline</a></li><li data-type='method'><a href="Polylinecurve.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="Polylinecurve.html#point">point</a></li><li data-type='method'><a href="Polylinecurve.html#pointAt">pointAt</a></li><li data-type='method'><a href="Polylinecurve.html#reverse">reverse</a></li><li data-type='method'><a href="Polylinecurve.html#rotate">rotate</a></li><li data-type='method'><a href="Polylinecurve.html#scale">scale</a></li><li data-type='method'><a href="Polylinecurve.html#setEndPoint">setEndPoint</a></li><li data-type='method'><a href="Polylinecurve.html#setPoint">setPoint</a></li><li data-type='method'><a href="Polylinecurve.html#setStartPoint">setStartPoint</a></li><li data-type='method'><a href="Polylinecurve.html#setUserString">setUserString</a></li><li data-type='method'><a href="Polylinecurve.html#tangentAt">tangentAt</a></li><li data-type='method'><a href="Polylinecurve.html#toJSON">toJSON</a></li><li data-type='method'><a href="Polylinecurve.html#toNurbsCurve">toNurbsCurve</a></li><li data-type='method'><a href="Polylinecurve.html#ToPolyline">ToPolyline</a></li><li data-type='method'><a href="Polylinecurve.html#transform">transform</a></li><li data-type='method'><a href="Polylinecurve.html#translate">translate</a></li><li data-type='method'><a href="Polylinecurve.html#trim">trim</a></li><li data-type='method'><a href="Polylinecurve.html#tryGetArc">tryGetArc</a></li><li data-type='method'><a href="Polylinecurve.html#tryGetCircle">tryGetCircle</a></li><li data-type='method'><a href="Polylinecurve.html#tryGetPolyline">tryGetPolyline</a></li></ul></li><li><a href="RevSurface.html">RevSurface</a><ul class='methods'><li data-type='method'><a href="RevSurface.html#degree">degree</a></li><li data-type='method'><a href="RevSurface.html#encode">encode</a></li><li data-type='method'><a href="RevSurface.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="RevSurface.html#getUserString">getUserString</a></li><li data-type='method'><a href="RevSurface.html#isAtSeam">isAtSeam</a></li><li data-type='method'><a href="RevSurface.html#isAtSingularity">isAtSingularity</a></li><li data-type='method'><a href="RevSurface.html#isClosed">isClosed</a></li><li data-type='method'><a href="RevSurface.html#isCone">isCone</a></li><li data-type='method'><a href="RevSurface.html#isCylinder">isCylinder</a></li><li data-type='method'><a href="RevSurface.html#isPeriodic">isPeriodic</a></li><li data-type='method'><a href="RevSurface.html#isPlanar">isPlanar</a></li><li data-type='method'><a href="RevSurface.html#isSingular">isSingular</a></li><li data-type='method'><a href="RevSurface.html#isSphere">isSphere</a></li><li data-type='method'><a href="RevSurface.html#isTorus">isTorus</a></li><li data-type='method'><a href="RevSurface.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="RevSurface.html#normalAt">normalAt</a></li><li data-type='method'><a href="RevSurface.html#pointAt">pointAt</a></li><li data-type='method'><a href="RevSurface.html#rotate">rotate</a></li><li data-type='method'><a href="RevSurface.html#scale">scale</a></li><li data-type='method'><a href="RevSurface.html#setUserString">setUserString</a></li><li data-type='method'><a href="RevSurface.html#spanCount">spanCount</a></li><li data-type='method'><a href="RevSurface.html#toJSON">toJSON</a></li><li data-type='method'><a href="RevSurface.html#transform">transform</a></li><li data-type='method'><a href="RevSurface.html#translate">translate</a></li></ul></li><li><a href="Sphere.html">Sphere</a><ul class='methods'><li data-type='method'><a href="Sphere.html#.decode">decode</a></li><li data-type='method'><a href="Sphere.html#closestPoint">closestPoint</a></li><li data-type='method'><a href="Sphere.html#encode">encode</a></li><li data-type='method'><a href="Sphere.html#latitudeDegrees">latitudeDegrees</a></li><li data-type='method'><a href="Sphere.html#latitudeRadians">latitudeRadians</a></li><li data-type='method'><a href="Sphere.html#longitudeRadians">longitudeRadians</a></li><li data-type='method'><a href="Sphere.html#longitureDegrees">longitureDegrees</a></li><li data-type='method'><a href="Sphere.html#normalAt">normalAt</a></li><li data-type='method'><a href="Sphere.html#pointAt">pointAt</a></li><li data-type='method'><a href="Sphere.html#toBrep">toBrep</a></li><li data-type='method'><a href="Sphere.html#toJSON">toJSON</a></li><li data-type='method'><a href="Sphere.html#toNurbsSurface">toNurbsSurface</a></li></ul></li><li><a href="Surface.html">Surface</a><ul class='methods'><li data-type='method'><a href="Surface.html#degree">degree</a></li><li data-type='method'><a href="Surface.html#encode">encode</a></li><li data-type='method'><a href="Surface.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="Surface.html#getUserString">getUserString</a></li><li data-type='method'><a href="Surface.html#isAtSeam">isAtSeam</a></li><li data-type='method'><a href="Surface.html#isAtSingularity">isAtSingularity</a></li><li data-type='method'><a href="Surface.html#isClosed">isClosed</a></li><li data-type='method'><a href="Surface.html#isCone">isCone</a></li><li data-type='method'><a href="Surface.html#isCylinder">isCylinder</a></li><li data-type='method'><a href="Surface.html#isPeriodic">isPeriodic</a></li><li data-type='method'><a href="Surface.html#isPlanar">isPlanar</a></li><li data-type='method'><a href="Surface.html#isSingular">isSingular</a></li><li data-type='method'><a href="Surface.html#isSphere">isSphere</a></li><li data-type='method'><a href="Surface.html#isTorus">isTorus</a></li><li data-type='method'><a href="Surface.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="Surface.html#normalAt">normalAt</a></li><li data-type='method'><a href="Surface.html#pointAt">pointAt</a></li><li data-type='method'><a href="Surface.html#rotate">rotate</a></li><li data-type='method'><a href="Surface.html#scale">scale</a></li><li data-type='method'><a href="Surface.html#setUserString">setUserString</a></li><li data-type='method'><a href="Surface.html#spanCount">spanCount</a></li><li data-type='method'><a href="Surface.html#toJSON">toJSON</a></li><li data-type='method'><a href="Surface.html#transform">transform</a></li><li data-type='method'><a href="Surface.html#translate">translate</a></li></ul></li><li><a href="SurfaceProxy.html">SurfaceProxy</a><ul class='methods'><li data-type='method'><a href="SurfaceProxy.html#degree">degree</a></li><li data-type='method'><a href="SurfaceProxy.html#encode">encode</a></li><li data-type='method'><a href="SurfaceProxy.html#getBoundingBox">getBoundingBox</a></li><li data-type='method'><a href="SurfaceProxy.html#getUserString">getUserString</a></li><li data-type='method'><a href="SurfaceProxy.html#isAtSeam">isAtSeam</a></li><li data-type='method'><a href="SurfaceProxy.html#isAtSingularity">isAtSingularity</a></li><li data-type='method'><a href="SurfaceProxy.html#isClosed">isClosed</a></li><li data-type='method'><a href="SurfaceProxy.html#isCone">isCone</a></li><li data-type='method'><a href="SurfaceProxy.html#isCylinder">isCylinder</a></li><li data-type='method'><a href="SurfaceProxy.html#isPeriodic">isPeriodic</a></li><li data-type='method'><a href="SurfaceProxy.html#isPlanar">isPlanar</a></li><li data-type='method'><a href="SurfaceProxy.html#isSingular">isSingular</a></li><li data-type='method'><a href="SurfaceProxy.html#isSphere">isSphere</a></li><li data-type='method'><a href="SurfaceProxy.html#isTorus">isTorus</a></li><li data-type='method'><a href="SurfaceProxy.html#makeDeformable">makeDeformable</a></li><li data-type='method'><a href="SurfaceProxy.html#normalAt">normalAt</a></li><li data-type='method'><a href="SurfaceProxy.html#pointAt">pointAt</a></li><li data-type='method'><a href="SurfaceProxy.html#rotate">rotate</a></li><li data-type='method'><a href="SurfaceProxy.html#scale">scale</a></li><li data-type='method'><a href="SurfaceProxy.html#setUserString">setUserString</a></li><li data-type='method'><a href="SurfaceProxy.html#spanCount">spanCount</a></li><li data-type='method'><a href="SurfaceProxy.html#toJSON">toJSON</a></li><li data-type='method'><a href="SurfaceProxy.html#transform">transform</a></li><li data-type='method'><a href="SurfaceProxy.html#translate">translate</a></li></ul></li><li><a href="Texture.html">Texture</a><ul class='methods'><li data-type='method'><a href="Texture.html#fileReference">fileReference</a></li></ul></li><li><a href="TextureMapping.html">TextureMapping</a><ul class='methods'><li data-type='method'><a href="TextureMapping.html#.CreateBoxMapping">CreateBoxMapping</a></li><li data-type='method'><a href="TextureMapping.html#.createCylinderMapping">createCylinderMapping</a></li><li data-type='method'><a href="TextureMapping.html#.createPlaneMapping">createPlaneMapping</a></li><li data-type='method'><a href="TextureMapping.html#.createSphereMapping">createSphereMapping</a></li><li data-type='method'><a href="TextureMapping.html#.createSurfaceParameterMapping">createSurfaceParameterMapping</a></li><li data-type='method'><a href="TextureMapping.html#encode">encode</a></li><li data-type='method'><a href="TextureMapping.html#evaluate">evaluate</a></li><li data-type='method'><a href="TextureMapping.html#getUserString">getUserString</a></li><li data-type='method'><a href="TextureMapping.html#reverseTextureCoordinate">reverseTextureCoordinate</a></li><li data-type='method'><a href="TextureMapping.html#setUserString">setUserString</a></li><li data-type='method'><a href="TextureMapping.html#swapTextureCoordinate">swapTextureCoordinate</a></li><li data-type='method'><a href="TextureMapping.html#tileTextureCoordinate">tileTextureCoordinate</a></li><li data-type='method'><a href="TextureMapping.html#toJSON">toJSON</a></li><li data-type='method'><a href="TextureMapping.html#tryGetMappingCylinder">tryGetMappingCylinder</a></li><li data-type='method'><a href="TextureMapping.html#tryGetMappingSphere">tryGetMappingSphere</a></li></ul></li><li><a href="Transform.html">Transform</a><ul class='methods'><li data-type='method'><a href="Transform.html#.identity">identity</a></li><li data-type='method'><a href="Transform.html#.rotation">rotation</a></li><li data-type='method'><a href="Transform.html#.scale">scale</a></li><li data-type='method'><a href="Transform.html#.translation">translation</a></li><li data-type='method'><a href="Transform.html#determinant">determinant</a></li><li data-type='method'><a href="Transform.html#transpose">transpose</a></li></ul></li><li><a href="ViewInfo.html">ViewInfo</a></li><li><a href="ViewportInfo.html">ViewportInfo</a><ul class='methods'><li data-type='method'><a href="ViewportInfo.html#changeToParallelProjection">changeToParallelProjection</a></li><li data-type='method'><a href="ViewportInfo.html#changeToPerspectiveProjection">changeToPerspectiveProjection</a></li><li data-type='method'><a href="ViewportInfo.html#changeToTwoPointPerspectiveProjection">changeToTwoPointPerspectiveProjection</a></li><li data-type='method'><a href="ViewportInfo.html#dollyExtents">dollyExtents</a></li><li data-type='method'><a href="ViewportInfo.html#encode">encode</a></li><li data-type='method'><a href="ViewportInfo.html#getFrustum">getFrustum</a></li><li data-type='method'><a href="ViewportInfo.html#getUserString">getUserString</a></li><li data-type='method'><a href="ViewportInfo.html#getXform">getXform</a></li><li data-type='method'><a href="ViewportInfo.html#setCameraDirection">setCameraDirection</a></li><li data-type='method'><a href="ViewportInfo.html#setCameraLocation">setCameraLocation</a></li><li data-type='method'><a href="ViewportInfo.html#setCameraUp">setCameraUp</a></li><li data-type='method'><a href="ViewportInfo.html#setFrustum">setFrustum</a></li><li data-type='method'><a href="ViewportInfo.html#setUserString">setUserString</a></li><li data-type='method'><a href="ViewportInfo.html#toJSON">toJSON</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">rh3dm_temp.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Arc
 */
class Arc {
  /**
   * @description Initializes a new horizontal arc at the given center point, with a custom radius and angle.
   * @param {Array.&lt;x,y,z>} center Center point of arc.
   * @param {double} radius Radius of arc.
   * @param {double} angleRadians Sweep angle of arc (in radians)
   */
  constructor(center,radius,angleRadians){}
  /**
   * @description Sets arc's angle domain (in radians) as a subdomain of the circle.
   * @param {Interval} domain 0 &lt; domain[1] - domain[0] &lt;= 2.0 * RhinoMath.Pi.
   * @returns {bool} true on success, false on failure.
   */
  trim(domain) {  }
  /**
   * @description Computes the 3D axis aligned bounding box for this arc.
   * @returns {BoundingBox} Bounding box of arc.
   */
  boundingBox() {  }
  /**
   * @description Gets the point at the given arc parameter.
   * @param {double} t Arc parameter to evaluate.
   * @returns {Array.&lt;x,y,z>} The point at the given parameter.
   */
  pointAt(t) {  }
  /**
   * @description Gets the tangent at the given parameter.
   * @param {double} t Parameter of tangent to evaluate.
   * @returns {Array.&lt;x,y,z>} The tangent at the arc at the given parameter.
   */
  tangentAt(t) {  }
  /**
   * @description Computes the point on an arc that is closest to a test point.
   * @param {Array.&lt;x,y,z>} testPoint Point to get close to.
   * @returns {Array.&lt;x,y,z>} The point on the arc that is closest to testPoint. If testPoint is
     the center of the arc, then the starting point of the arc is returned.
     UnsetPoint on failure.
   */
  closestPoint(testPoint) {  }
  /**
   * @description Reverses the orientation of the arc. Changes the domain from [a,b]
     to [-b,-a].
   */
  reverse() {  }
  /**
   * @description Transforms the arc using a Transformation matrix.
   * @param {Transform} xform Transformations to apply. 
     Note that arcs cannot handle non-euclidian transformations.
   * @returns {bool} true on success, false on failure.
   */
  transform(xform) {  }
  /**
   * @description Initializes a nurbs curve representation of this arc. 
     This amounts to the same as calling NurbsCurve.CreateFromArc().
   * @returns {NurbsCurve} A nurbs curve representation of this arc or null if no such representation could be made.
   */
  toNurbsCurve() {  }
  /**
   * @description Gets a value indicating whether or not this arc is valid.
     Detail:
    	 Radius>0 and 0&lt;AngleRadians()&lt;=2*Math.Pi.
   * @returns {bool} true if the arc is valid.
   * @type {bool}
   */
  get isValid() { return null;}
  /**
   * @description Gets a value indicating whether or not this arc is a complete circle.
   * @type {bool}
   */
  get isCircle() { return null;}
  /**
   * @description Gets or sets the radius of this arc.
   * @type {double}
   */
  get radius() { return null;}
  /**
   * @description Gets or sets the Diameter of this arc.
   * @type {double}
   */
  get diameter() { return null;}
  /**
   * @description Gets or sets the center point for this arc.
   * @type {Array.&lt;x,y,z>}
   */
  get center() { return null;}
  /**
   * @description Gets the circumference of the circle that is coincident with this arc.
   * @type {double}
   */
  get circumference() { return null;}
  /**
   * @description Gets the length of the arc. (Length = Radius * (subtended angle in radians)).
   * @type {double}
   */
  get length() { return null;}
  /**
   * @description Gets the start point of the arc.
   * @type {Array.&lt;x,y,z>}
   */
  get startPoint() { return null;}
  /**
   * @description Gets the mid-point of the arc.
   * @type {Array.&lt;x,y,z>}
   */
  get midPoint() { return null;}
  /**
   * @description Gets the end point of the arc.
   * @type {Array.&lt;x,y,z>}
   */
  get endPoint() { return null;}
  /**
   */
  get angleRadians() { return null;}
  /**
   * @description Gets or sets the sweep -or subtended- angle (in Radians) for this arc segment.
   * @type {double}
   */
  get angleDegrees() { return null;}
}
/**
 &lt;summary>
   Represent arcs and circles.
   &lt;para>ArcCurve.IsCircle returns true if the curve is a complete circle.&lt;/para>
   &lt;/summary>
   &lt;remarks>
   &lt;para>Details:&lt;/para>
   &lt;para>an ArcCurve is a subcurve of a circle, with a constant speed
   parameterization. The parameterization is	an affine linear
   reparameterzation of the underlying arc	m_arc onto the domain m_t.&lt;/para>
   &lt;para>A valid ArcCurve has Radius()>0 and  0&amp;lt;AngleRadians()&amp;lt;=2*PI
   and a strictly increasing Domain.&lt;/para>
   &lt;/remarks>
 * @extends Curve
 */
class ArcCurve {
  /**
   * @description Gets a value indicating whether or not this curve can be represented by a complete circle.
   * @type {bool}
   */
  get isCompleteCircle() { return null;}
  /**
   * @description Gets the radius of this ArcCurve.
   * @type {double}
   */
  get radius() { return null;}
  /**
   * @description Gets the angles of this arc in radians.
   * @type {double}
   */
  get angleRadians() { return null;}
  /**
   * @description Gets the angles of this arc in degrees.
   * @type {double}
   */
  get angleDegrees() { return null;}
}
/**
 &lt;summary>
   Represents a Bezier curve.
   &lt;para>Note: as an exception, the bezier curve &lt;b>is not&lt;/b> derived from &lt;see cref="Curve"/>.&lt;/para>
   &lt;/summary>
 * @hideconstructor
 */
class BezierCurve {
  /**
   * @description Evaluates point at a curve parameter.
   * @param {double} t Evaluation parameter.
   * @returns {Array.&lt;x,y,z>} Point (location of curve at the parameter t).
   */
  pointAt(t) {  }
  /**
   * @description Evaluates the unit tangent vector at a curve parameter.
   * @param {double} t Evaluation parameter.
   * @returns {Array.&lt;x,y,z>} Unit tangent vector of the curve at the parameter t.
   */
  tangentAt(t) {  }
  /**
   * @description Evaluate the curvature vector at a curve parameter.
   * @param {double} t Evaluation parameter.
   * @returns {Array.&lt;x,y,z>} Curvature vector of the curve at the parameter t.
   */
  curvatureAt(t) {  }
  /**
   * @description Make bezier rational
   * @returns {bool} true if successful
   */
  makeRational() {  }
  /**
   * @description Make bezier non-rational
   * @returns {bool} treu if successful
   */
  makeNonRational() {  }
  /**
   * @description Increase degree of bezier
   * @returns {bool} true if successful.  false if desiredDegree &lt; current degree.
   */
  increaseDegree() {  }
  /**
   * @description Change dimension of bezier.
   * @returns {bool} true if successful.  false if desired_dimension &lt; 1
   */
  changeDimension() {  }
  /**
   * @description Dimension of Bezier
   * @type {int}
   */
  get dimension() { return null;}
  /**
   * @description Tests an object to see if it is valid.
   * @type {bool}
   */
  get isValid() { return null;}
  /**
   * @description Gets a value indicating whether or not the curve is rational. 
     Rational curves have control-points with custom weights.
   * @type {bool}
   */
  get isRational() { return null;}
  /**
   * @description Number of control vertices in this curve
   * @type {int}
   */
  get controlVertexCount() { return null;}
}
/**
 * Bitmap
 */
class Bitmap {
  /**
   */
  get width() { return null;}
  /**
   */
  get height() { return null;}
  /**
   */
  get bitsPerPixel() { return null;}
  /**
   */
  get sizeOfScan() { return null;}
  /**
   */
  get sizeOfImage() { return null;}
}
/**
 * BoundingBox
 */
class BoundingBox {
  /**
   * @description Constructs a new boundingbox from two corner points.
   * @param {Array.&lt;x,y,z>} min Point containing all the minimum coordinates.
   * @param {Array.&lt;x,y,z>} max Point containing all the maximum coordinates.
   */
  constructor(min,max){}
  /**
   * @description Constructs a boundingbox from numeric extremes.
   * @param {double} minX Lower extreme for box X size.
   * @param {double} minY Lower extreme for box Y size.
   * @param {double} minZ Lower extreme for box Z size.
   * @param {double} maxX Upper extreme for box X size.
   * @param {double} maxY Upper extreme for box Y size.
   * @param {double} maxZ Upper extreme for box Z size.
   */
  closestPoint(point) {  }
  /**
   * @description Tests a point for boundingbox inclusion. This is the same as calling Contains(point, false)
   * @param {Array.&lt;x,y,z>} point Point to test.
   * @returns {bool} true if the point is on the inside of or coincident with this boundingbox; otherwise false.
   */
  contains(point) {  }
  /**
   * @description Determines whether a bounding box is degenerate (flat) in one or more directions.
   * @param {double} tolerance Distances &lt;= tolerance will be considered to be zero.  If tolerance
     is negative (default), then a scale invarient tolerance is used.
   * @returns {int} 0 = box is not degenerate
     1 = box is a rectangle (degenerate in one direction).
     2 = box is a line (degenerate in two directions).
     3 = box is a point (degenerate in three directions)
     4 = box is not valid.
   */
  isDegenerate(tolerance) {  }
  /**
   * @description Updates this boundingbox to be the smallest axis aligned
     boundingbox that contains the transformed result of its 8 original corner
     points.
   * @param {Transform} xform A transform.
   * @returns {bool} true if this operation is sucessfull; otherwise false.
   */
  transform(xform) {  }
  /**
   * @description Constructs a  representation of this boundingbox.
   * @returns {Brep} If this operation is sucessfull, a Brep representation of this box; otherwise null.
   */
  toBrep() {  }
  /**
   * @description Updates this BoundingBox to represent the union of itself and another box.
   * @param {BoundingBox} other Box to include in this union.
   */
  static union(other) {  }
  /** ... */
  encode() {  }
  /** ... */
  toJSON() {  }
  /** ... */
  static decode() {  }
  /**
   * @description Gets a value that indicates whether or not this boundingbox is valid. 
     Empty boxes are not valid, and neither are boxes with unset points.
   * @type {bool}
   */
  get isValid() { return null;}
  /**
   * @description Gets or sets the point in the minimal corner.
   * @type {Array.&lt;x,y,z>}
   */
  get min() { return null;}
  /**
   * @description Gets or sets the point in the maximal corner.
   * @type {Array.&lt;x,y,z>}
   */
  get max() { return null;}
  /**
   * @description Gets the point in the center of the boundingbox.
   * @type {Array.&lt;x,y,z>}
   */
  get center() { return null;}
  /**
   * @description Gets the area of this BoundingBox.
   * @type {double}
   */
  get area() { return null;}
  /**
   * @description Gets the volume of this BoundingBox.
   * @type {double}
   */
  get volume() { return null;}
  /**
   * @description Gets the diagonal vector of this BoundingBox. 
     The diagonal connects the Min and Max points.
   * @type {Array.&lt;x,y,z>}
   */
  get diagonal() { return null;}
}
/**
 * Box
 */
class Box {
  /**
   * @description Evaluates the box volume at the given unitized parameters.
     The box has idealized side length of 1x1x1.
   * @param {double} x Unitized parameter (between 0 and 1 is inside the box) along box X direction.
   * @param {double} y Unitized parameter (between 0 and 1 is inside the box) along box Y direction.
   * @param {double} z Unitized parameter (between 0 and 1 is inside the box) along box Z direction.
   * @returns {Array.&lt;x,y,z>} The point at (x,y,z).
   */
  pointAt(x,y,z) {  }
  /**
   * @description Finds the closest point on or in the Box. The box should be Valid for this to work.
   * @param {Array.&lt;x,y,z>} point Sample point.
   * @returns {Array.&lt;x,y,z>} The point on or in the box that is closest to the sample point.
   */
  closestPoint(point) {  }
  /**
   * @description Transforms this Box using a Transformation matrix. If the Transform does not preserve 
     Similarity, the dimensions of the resulting box cannot be trusted.
   * @param {Transform} xform Transformation matrix to apply to this Box.
   * @returns {bool} true if the Box was successfully transformed, false if otherwise.
   */
  transform(xform) {  }
  /**
   * @description Gets the validity of this Box. Boxes are invalid when the base plane or any of 
     the dimension intervals are invalid or decreasing.
   * @type {bool}
   */
  get isValid() { return null;}
  /**
   * @description Gets the point that is in the center of the box.
   * @type {Array.&lt;x,y,z>}
   */
  get center() { return null;}
  /**
   * @description Gets the total surface area of this box.
   * @type {double}
   */
  get area() { return null;}
  /**
   * @description Gets the total volume of this box.
   * @type {double}
   */
  get volume() { return null;}
}
/**
 &lt;summary>
   Boundary Representation. A surface or polysurface along with trim curve information.
   &lt;/summary>
 * @extends GeometryBase
 */
class Brep {
  /** ... */
  faces() {  }
}
/**
 &lt;summary>
   Provides strongly-typed access to brep faces.
   &lt;para>A Brep face is composed of one surface and trimming curves.&lt;/para>
   &lt;/summary>
 * @extends SurfaceProxy
 * @hideconstructor
 */
class BrepFace {
  /**
   * @description Obtains a reference to a specified type of mesh for this brep face.
   * @param {MeshType} meshType The mesh type.
   * @returns {Mesh} A mesh.
   */
  getMesh(meshType) {  }
}
/**
 &lt;summary>
   Provides access to all the Faces in a Brep object.
   &lt;/summary>
 * @hideconstructor
 */
class BrepFaceList {
  /** ... */
  get() {  }
  /**
   * @description Gets the number of brep faces.
   * @type {int}
   */
  get count() { return null;}
}
/**
 * Circle
 */
class Circle {
  /**
   * @description Initializes a circle with center (0,0,0) in the world XY plane.
   * @param {double} radius Radius of circle, should be a positive number.
   */
  constructor(radius){}
  /**
   * @description Initializes a circle parallel to the world XY plane with given center and radius.
   * @param {Array.&lt;x,y,z>} center Center of circle.
   * @param {double} radius Radius of circle (should be a positive value).
   */
  pointAt(t) {  }
  /**
   * @description Circles use trigonometric parameterization: 
     t -> center + cos(t)*radius*xaxis + sin(t)*radius*yaxis.
   * @param {double} t Parameter of tangent to evaluate.
   * @returns {Array.&lt;x,y,z>} The tangent at the circle at the given parameter.
   */
  tangentAt(t) {  }
  /**
   * @description Determines the value of the Nth derivative at a parameter.
   * @param {int} derivative Which order of derivative is wanted.
   * @param {double} t Parameter to evaluate derivative. Valid values are 0, 1, 2 and 3.
   * @returns {Array.&lt;x,y,z>} The derivative of the circle at the given parameter.
   */
  derivativeAt(derivative,t) {  }
  /**
   * @description Gets the point on the circle which is closest to a test point.
   * @param {Array.&lt;x,y,z>} testPoint Point to project onto the circle.
   * @returns {Array.&lt;x,y,z>} The point on the circle that is closest to testPoint or
     Point3d.Unset on failure.
   */
  closestPoint(testPoint) {  }
  /**
   * @description Moves the circle.
   * @param {Array.&lt;x,y,z>} delta Translation vector.
   * @returns {bool} true on success, false on failure.
   */
  translate(delta) {  }
  /**
   * @description Reverse the orientation of the circle. Changes the domain from [a,b]
     to [-b,-a].
   */
  reverse() {  }
  /**
   * @description Constructs a nurbs curve representation of this circle. 
     This amounts to the same as calling NurbsCurve.CreateFromCircle().
   * @returns {NurbsCurve} A nurbs curve representation of this circle or null if no such representation could be made.
   */
  toNurbsCurve() {  }
  /**
   * @description A valid circle has radius larger than 0.0 and a base plane which is must also be valid.
   * @type {bool}
   */
  get isValid() { return null;}
  /**
   * @description Gets or sets the radius of this circle. 
     Radii should be positive values.
   * @type {double}
   */
  get radius() { return null;}
  /**
   * @description Gets or sets the diameter (radius * 2.0) of this circle. 
     Diameters should be positive values.
   * @type {double}
   */
  get diameter() { return null;}
  /**
   * @description Gets or sets the center point of this circle.
   * @type {Array.&lt;x,y,z>}
   */
  get center() { return null;}
  /**
   * @description Gets the normal vector for this circle.
   * @type {Array.&lt;x,y,z>}
   */
  get normal() { return null;}
  /**
   * @description Gets or sets the circumference of this circle.
   * @type {double}
   */
  get circumference() { return null;}
}
/**
 &lt;summary>
   Base class for .NET classes that wrap C++ unmanaged Rhino classes.
   &lt;/summary>
 * @hideconstructor
 */
class CommonObject {
  /** ... */
  encode() {  }
  /** ... */
  toJSON() {  }
  /** ... */
  static decode() {  }
  /** ... */
  setUserString() {  }
  /** ... */
  getUserString() {  }
  /**
   */
  get userStringCount() { return null;}
}
/**
 * Cone
 * @hideconstructor
 */
class Cone {
  /**
   * @description Constructs a Nurbs surface representation of this Cone. 
     This is synonymous with calling NurbsSurface.CreateFromCone().
   * @returns {NurbsSurface} A Nurbs surface representation of the cone or null.
   */
  toNurbsSurface() {  }
  /**
   * @description Gets a Brep representation of the cone with a single
     face for the cone, an edge along the cone seam, 
     and vertices at the base and apex ends of this seam edge.
     The optional cap is a single face with one circular edge 
     starting and ending at the base vertex.
   * @param {bool} capBottom true if the bottom should be filled with a surface. false otherwise.
   * @returns {Brep} A brep (polysurface) representation of this cone values.
   */
  toBrep(capBottom) {  }
  /**
   * @description Gets or sets the height of the circular right cone.
   * @type {double}
   */
  get height() { return null;}
  /**
   * @description Gets or sets the radius of the cone.
   * @type {double}
   */
  get radius() { return null;}
  /**
   * @description true if plane is valid, height is not zero and radius is not zero.
   * @type {bool}
   */
  get isValid() { return null;}
  /**
   * @description Center of base circle.
   * @type {Array.&lt;x,y,z>}
   */
  get basePoint() { return null;}
  /**
   * @description Point at tip of the cone.
   * @type {Array.&lt;x,y,z>}
   */
  get apexPoint() { return null;}
  /**
   * @description Unit vector axis of cone.
   * @type {Array.&lt;x,y,z>}
   */
  get axis() { return null;}
  /**
   */
  get angleInRadians() { return null;}
  /**
   */
  get angleInDegrees() { return null;}
}
/**
 &lt;summary>
   Represents a contruction plane inside the document.
   &lt;para>Use Rhino.DocObjects.Tables.NamedConstructionPlaneTable
   methods and indexers to add and access a &lt;see cref="ConstructionPlane"/>.&lt;/para>
   &lt;/summary>
 */
class ConstructionPlane {
  /**
   * @description Gets or sets the geometric plane to use for construction.
   * @type {Plane}
   */
  get plane() { return null;}
  /**
   * @description Gets or sets the distance between grid lines.
   * @type {double}
   */
  get gridSpacing() { return null;}
  /**
   * @description when "grid snap" is enabled, the distance between snap points.
     Typically this is the same distance as grid spacing.
   * @type {double}
   */
  get snapSpacing() { return null;}
  /**
   * @description Gets or sets the total amount of grid lines in each direction.
   * @type {int}
   */
  get gridLineCount() { return null;}
  /**
   * @description Gets or sets the recurrence of a wider line on the grid.
     0: No lines are thick, all are drawn thin.1: All lines are thick.2: Every other line is thick.3: One line in three lines is thick (and two are thin).4: ...
   * @type {int}
   */
  get thickLineFrequency() { return null;}
  /**
   * @description Gets or sets whether the grid is drawn on top of geometry.
     false=grid is always drawn behind 3d geometrytrue=grid is drawn at its depth as a 3d plane and grid lines obscure things behind the grid.
   * @type {bool}
   */
  get depthBuffered() { return null;}
  /**
   * @description Gets or sets the name of the construction plane.
   * @type {string}
   */
  get name() { return null;}
}
/**
 &lt;summary>
   Represents a base class that is common to most RhinoCommon curve types.
   &lt;para>A curve represents an entity that can be all visited by providing
   a single parameter, usually called t.&lt;/para>
   &lt;/summary>
 * @extends GeometryBase
 * @hideconstructor
 */
class Curve {
  /**
   * @description Changes the dimension of a curve.
   * @param {int} desiredDimension The desired dimension.
   * @returns {bool} true if the curve's dimension was already desiredDimension
     or if the curve's dimension was successfully changed to desiredDimension;
     otherwise false.
   */
  changeDimension(desiredDimension) {  }
  /**
   * @description Test a curve to see if it is linear to within RhinoMath.ZeroTolerance units (1e-12).
   * @returns {bool} true if the curve is linear.
   */
  isLinear() {  }
  /**
   * @description Several types of Curve can have the form of a polyline
     including a degree 1 NurbsCurve, a PolylineCurve,
     and a PolyCurve all of whose segments are some form of
     polyline. IsPolyline tests a curve to see if it can be
     represented as a polyline.
   * @returns {bool} true if this curve can be represented as a polyline; otherwise, false.
   */
  isPolyline() {  }
  /**
   * @description Several types of Curve can have the form of a polyline 
     including a degree 1 NurbsCurve, a PolylineCurve, 
     and a PolyCurve all of whose segments are some form of 
     polyline. IsPolyline tests a curve to see if it can be 
     represented as a polyline.
   * @param {Polyline} polyline If true is returned, then the polyline form is returned here.
   * @returns {bool} true if this curve can be represented as a polyline; otherwise, false.
   */
  tryGetPolyline(polyline) {  }
  /**
   * @description Test a curve to see if it can be represented by an arc or circle within RhinoMath.ZeroTolerance.
   * @returns {bool} true if the curve can be represented by an arc or a circle within tolerance.
   */
  isArc() {  }
  /**
   * @description Try to convert this curve into an Arc using RhinoMath.ZeroTolerance.
   * @param {Arc} arc On success, the Arc will be filled in.
   * @returns {bool} true if the curve could be converted into an arc.
   */
  tryGetArc(arc) {  }
  /**
   * @description Test a curve to see if it can be represented by a circle within RhinoMath.ZeroTolerance.
   * @returns {bool} true if the Curve can be represented by a circle within tolerance.
   */
  isCircle() {  }
  /**
   * @description Try to convert this curve into a circle using RhinoMath.ZeroTolerance.
   * @param {Circle} circle On success, the Circle will be filled in.
   * @returns {bool} true if the curve could be converted into a Circle.
   */
  tryGetCircle(circle) {  }
  /**
   * @description Test a curve to see if it can be represented by an ellipse within RhinoMath.ZeroTolerance.
   * @returns {bool} true if the Curve can be represented by an ellipse within tolerance.
   */
  isEllipse() {  }
  /**
   * @description Test a curve for planarity.
   * @returns {bool} true if the curve is planar (flat) to within RhinoMath.ZeroTolerance units (1e-12).
   */
  isPlanar() {  }
  /**
   * @description If this curve is closed, then modify it so that the start/end point is at curve parameter t.
   * @param {double} t Curve parameter of new start/end point. The returned curves domain will start at t.
   * @returns {bool} true on success, false on failure.
   */
  changeClosedCurveSeam(t) {  }
  /**
   * @description Reverses the direction of the curve.
   * @returns {bool} true on success, false on failure.
   */
  reverse() {  }
  /**
   * @description Evaluates point at a curve parameter.
   * @param {double} t Evaluation parameter.
   * @returns {Array.&lt;x,y,z>} Point (location of curve at the parameter t).
   */
  pointAt(t) {  }
  /**
   * @description Forces the curve to start at a specified point. 
     Not all curve types support this operation.
   * @param {Array.&lt;x,y,z>} point New start point of curve.
   * @returns {bool} true on success, false on failure.
   */
  setStartPoint(point) {  }
  /**
   * @description Forces the curve to end at a specified point. 
     Not all curve types support this operation.
   * @param {Array.&lt;x,y,z>} point New end point of curve.
   * @returns {bool} true on success, false on failure.
   */
  setEndPoint(point) {  }
  /**
   * @description Evaluates the unit tangent vector at a curve parameter.
   * @param {double} t Evaluation parameter.
   * @returns {Array.&lt;x,y,z>} Unit tangent vector of the curve at the parameter t.
   */
  tangentAt(t) {  }
  /**
   * @description Evaluate the curvature vector at a curve parameter.
   * @param {double} t Evaluation parameter.
   * @returns {Array.&lt;x,y,z>} Curvature vector of the curve at the parameter t.
   */
  curvatureAt(t) {  }
  /**
   * @description Removes portions of the curve outside the specified interval.
   * @param {double} t0 Start of the trimming interval. Portions of the curve before curve(t0) are removed.
   * @param {double} t1 End of the trimming interval. Portions of the curve after curve(t1) are removed.
   * @returns {Curve} Trimmed portion of this curve is successfull, null on failure.
   */
  trim(t0,t1) {  }
  /**
   * @description Constructs a NURBS curve representation of this curve.
   * @returns {NurbsCurve} NURBS representation of the curve on success, null on failure.
   */
  toNurbsCurve() {  }
  /**
   * @description Gets or sets the domain of the curve.
   * @type {Interval}
   */
  get domain() { return null;}
  /**
   * @description Gets the dimension of the object.
     The dimension is typically three. For parameter space trimming
     curves the dimension is two. In rare cases the dimension can
     be one or greater than three.
   * @type {int}
   */
  get dimension() { return null;}
  /**
   * @description Gets the number of non-empty smooth (c-infinity) spans in the curve.
   * @type {int}
   */
  get spanCount() { return null;}
  /**
   * @description Gets the maximum algebraic degree of any span
     or a good estimate if curve spans are not algebraic.
   * @type {int}
   */
  get degree() { return null;}
  /**
   * @description Gets a value indicating whether or not this curve is a closed curve.
   * @type {bool}
   */
  get isClosed() { return null;}
  /**
   * @description Gets a value indicating whether or not this curve is considered to be Periodic.
   * @type {bool}
   */
  get isPeriodic() { return null;}
  /**
   * @description Evaluates point at the start of the curve.
   * @type {Array.&lt;x,y,z>}
   */
  get pointAtStart() { return null;}
  /**
   * @description Evaluates point at the end of the curve.
   * @type {Array.&lt;x,y,z>}
   */
  get pointAtEnd() { return null;}
}
/**
 &lt;summary>
   Provides strongly-typed access to Brep edges.
   &lt;/summary>
 * @extends Curve
 * @hideconstructor
 */
class CurveProxy {
  /**
   * @description True if "this" is a curve is reversed from the "real" curve geometry
   * @type {bool}
   */
  get proxyCurveIsReversed() { return null;}
}
/**
 * Cylinder
 */
class Cylinder {
  /**
   * @description Compute the circle at the given elevation parameter.
   * @param {double} linearParameter Height parameter for circle section.
   */
  circleAt(linearParameter) {  }
  /**
   * @description Constructs a Brep representation of this Cylinder. 
     This is synonymous with calling NurbsSurface.CreateFromCylinder().
   * @param {bool} capBottom If true, the bottom of the cylinder will be capped.
   * @param {bool} capTop If true, the top of the cylinder will be capped.
   * @returns {Brep} A Brep representation of the cylinder or null.
   */
  toBrep(capBottom,capTop) {  }
  /**
   * @description Constructs a Nurbs surface representation of this cylinder. 
     This is synonymous with calling NurbsSurface.CreateFromCylinder().
   * @returns {NurbsSurface} A Nurbs surface representation of the cylinder or null.
   */
  toNurbsSurface() {  }
  /**
   * @description Gets a boolean value indicating whether this cylinder is valid.
     A valid cylinder is represented by a valid circle and two valid heights.
   * @type {bool}
   */
  get isValid() { return null;}
  /**
   * @description true if the cylinder is finite (Height0 != Height1)
     false if the cylinder is infinite.
   * @type {bool}
   */
  get isFinite() { return null;}
  /**
   * @description Gets the center point of the defining circle.
   * @type {Array.&lt;x,y,z>}
   */
  get center() { return null;}
  /**
   * @description Gets the axis direction of the cylinder.
   * @type {Array.&lt;x,y,z>}
   */
  get axis() { return null;}
  /**
   * @description Gets the height of the cylinder. 
     Infinite cylinders have a height of zero, not Double.PositiveInfinity.
   * @type {double}
   */
  get totalHeight() { return null;}
  /**
   * @description Gets or sets the start height of the cylinder.
     The center of bottom cap is: BasePlane.Origin + Height1 * BasePlane.ZAxis.
   * @type {double}
   */
  get height1() { return null;}
  /**
   * @description Gets or sets the end height of the cylinder. 
     If the end height equals the start height, the cylinder is 
     presumed to be infinite.
     The center of top cap is: BasePlane.Origin + Height2 * BasePlane.ZAxis.
   * @type {double}
   */
  get height2() { return null;}
  /**
   * @description Gets or sets the radius of the cylinder.
   * @type {double}
   */
  get radius() { return null;}
}
/**
 * Ellipse
 * @hideconstructor
 */
class Ellipse {
}
/**
 &lt;summary>
   Represents an extrusion, or objects such as beams or linearly extruded elements,
   that can be represented by profile curves and two miter planes at the extremes.
   &lt;/summary>
 * @extends Surface
 */
class Extrusion {
  /**
   * @description Creates an extrusion of a 3d curve (which must be planar) and a height.
   * @param {Curve} planarCurve Planar curve used as profile
   * @param {double} height If the height > 0, the bottom of the extrusion will be in plane and
     the top will be height units above the plane.
     If the height &lt; 0, the top of the extrusion will be in plane and
     the bottom will be height units below the plane.
     The plane used is the one that is returned from the curve's TryGetPlane function.
   * @param {bool} cap If the curve is closed and cap is true, then the resulting extrusion is capped.
   * @returns {Extrusion} If the input is valid, then a new extrusion is returned. Otherwise null is returned
   */
  static create(planarCurve,height,cap) {  }
  /**
   * @description Gets an extrusion form of a cylinder.
   * @param {Cylinder} cylinder IsFinite must be true.
   * @param {bool} capBottom If true, the end at cylinder.Height1 will be capped.
   * @param {bool} capTop If true, the end at cylinder.Height2 will be capped.
   * @returns {Extrusion} Extrusion on success. null on failure.
   */
  static createCylinderExtrusion(cylinder,capBottom,capTop) {  }
  /**
   * @description Gets an extrusion form of a pipe.
   * @param {Cylinder} cylinder IsFinite must be true.
   * @param {double} otherRadius If cylinder.Radius is less than other radius, then the cylinder will be the inside
     of the pipe.
   * @param {bool} capBottom If true, the end at cylinder.Height1 will be capped.
   * @param {bool} capTop If true, the end at cylinder.Height2 will be capped.
   * @returns {Extrusion} Extrusion on success. null on failure.
   */
  static createPipeExtrusion(cylinder,otherRadius,capBottom,capTop) {  }
  /**
   * @description Constructs a brep form of the extrusion. The outer profile is always the first face of the brep.
     If there are inner profiles, additional brep faces are created for each profile. If the
     outer profile is closed, then end caps are added as the last two faces of the brep.
   * @param {bool} splitKinkyFaces If true and the profiles have kinks, then the faces corresponding to those profiles are split
     so they will be G1.
   * @returns {Brep} A brep with a similar shape like this extrustion, or null on error.
   */
  toBrep(splitKinkyFaces) {  }
  /**
   * @description Allows to set the two points at the extremes and the up vector.
   * @param {Array.&lt;x,y,z>} a The start point.
   * @param {Array.&lt;x,y,z>} b The end point.
   * @param {Array.&lt;x,y,z>} up The up vector.
   * @returns {bool} true if the operation succeeded; otherwise false.
     Setting up=a-b will make the operation fail.
   */
  setPathAndUp(a,b,up) {  }
  /**
   * @description Obtains a reference to a specified type of mesh for this extrusion.
   * @param {MeshType} meshType The mesh type.
   * @returns {Mesh} A mesh.
   */
  getMesh(meshType) {  }
  /**
   * @description Gets the start point of the path.
   * @type {Array.&lt;x,y,z>}
   */
  get pathStart() { return null;}
  /**
   * @description Gets the end point of the path.
   * @type {Array.&lt;x,y,z>}
   */
  get pathEnd() { return null;}
  /**
   * @description Gets the up vector of the path.
   * @type {Array.&lt;x,y,z>}
   */
  get pathTangent() { return null;}
  /**
   * @description Gets a value indicating whether there is no gap among all surfaces constructing this object.
   * @type {bool}
   */
  get isSolid() { return null;}
  /**
   * @description Gets the amount of capping surfaces.
   * @type {int}
   */
  get capCount() { return null;}
}
/**
 &lt;summary>
   Represents a 3dm file, which is stored using the OpenNURBS file standard.
   &lt;para>The 3dm format is the main Rhinoceros storage format.&lt;/para>
   &lt;para>Visit http://www.opennurbs.com/ for more details.&lt;/para>
   &lt;/summary>
 */
class File3dm {
  /** ... */
  static fromByteArray() {  }
  /** ... */
  objects() {  }
  /** ... */
  layers() {  }
  /**
   * @description Gets or sets the start section comments, which are the comments with which the 3dm file begins.
   * @type {string}
   */
  get startSectionComments() { return null;}
  /**
   * @description Gets or sets the name of the application that wrote this file.
   * @type {string}
   */
  get applicationName() { return null;}
  /**
   * @description Gets or sets a URL for the application that wrote this file.
   * @type {string}
   */
  get applicationUrl() { return null;}
  /**
   * @description Gets or sets details for the application that wrote this file.
   * @type {string}
   */
  get applicationDetails() { return null;}
  /**
   * @description Gets a string that names the user who created the file.
   * @type {string}
   */
  get createdBy() { return null;}
  /**
   * @description Gets a string that names the user who last edited the file.
   * @type {string}
   */
  get lastEditedBy() { return null;}
  /**
   * @description Gets or sets the revision number.
   * @type {int}
   */
  get revision() { return null;}
}
/**
 &lt;summary>
   Provides access to layers in the 3dm file.
   &lt;/summary>
 * @hideconstructor
 */
class File3dmLayerTable {
  /** ... */
  count() {  }
  /** ... */
  get() {  }
  /** ... */
  add() {  }
  /**
   * @description Finds a Layer given its name.
   * @param {string} name The name of the Layer to be searched.
   * @param {Guid} parentId The id of the parent Layer to be searched.
   * @returns {Layer} A Layer, or null on error.
   */
  findName(name,parentId) {  }
  /**
   * @description Retrieves a Layer object based on Index. This seach type of search is discouraged.
     We are moving towards using only IDs for all tables.
   * @param {int} index The index to search for.
   * @returns {Layer} A Layer object, or null if none was found.
   */
  findIndex(index) {  }
  /** ... */
  findId() {  }
}
/**
 &lt;summary>
   Used to store geometry table object definition and attributes in a File3dm.
   &lt;/summary>
 * @hideconstructor
 */
class File3dmObject {
  /** ... */
  attributes() {  }
  /** ... */
  geometry() {  }
}
/**
 &lt;summary>
   Represents a simple object table for a file that is open externally.
   &lt;para>This class mimics Rhino.DocObjects.Tables.ObjectTable while providing external eccess to the file.&lt;/para>
   &lt;/summary>
 * @hideconstructor
 */
class File3dmObjectTable {
  /** ... */
  get() {  }
  /**
   * @description Gets the bounding box containing every object in this table.
   * @returns {Rhino.Geometry.BoundingBox} The computed bounding box.
   */
  getBoundingBox() {  }
  /**
   * @description Adds a point object to the table.
   * @param {double} x X component of point coordinate.
   * @param {double} y Y component of point coordinate.
   * @param {double} z Z component of point coordinate.
   * @returns {Guid} id of new object.
   */
  addPoint(x,y,z) {  }
  /**
   * @description Adds a line object to Rhino.
   * @param {Array.&lt;x,y,z>} from A line start point.
   * @param {Array.&lt;x,y,z>} to A line end point.
   * @returns {Guid} A unique identifier of new rhino object.
   */
  addLine(from,to) {  }
  /**
   * @description Adds a curve object to the document representing a circle.
   * @param {Circle} circle A circle to add.
   * @returns {Guid} A unique identifier for the object.
   */
  addCircle(circle) {  }
  /**
   * @description Adds a surface object to the document representing a sphere.
   * @param {Sphere} sphere A sphere to add.
   * @returns {Guid} A unique identifier for the object.
   */
  addSphere(sphere) {  }
  /**
   * @description Adds a curve object to the table.
   * @param {Geometry.Curve} curve A curve to add.
   * @returns {Guid} A unique identifier for the object.
   */
  addCurve(curve) {  }
  /**
   * @description Adds a text dot object to the table.
   * @param {string} text The text.
   * @param {Array.&lt;x,y,z>} location The location.
   * @returns {Guid} A unique identifier for the object.
   */
  addTextDot(text,location) {  }
  /**
   * @description Adds a mesh object to Rhino.
   * @param {Geometry.Mesh} mesh A duplicate of this mesh is added to Rhino.
   * @returns {Guid} A unique identifier for the object.
   */
  addMesh(mesh) {  }
  /**
   * @description Adds a brep object to Rhino.
   * @param {Geometry.Brep} brep A duplicate of this brep is added to Rhino.
   * @returns {Guid} A unique identifier for the object.
   */
  addBrep(brep) {  }
  /**
   * @description Returns the total amount of items in the object table, including lights.
   * @type {int}
   */
  get count() { return null;}
}
/**
 &lt;summary>
   Manages a reference to an existing or nonexisting file,
   using either or both absolute or relative paths.
   Once constructed, this class is immutable.
   &lt;/summary>
 * @hideconstructor
 */
class FileReference {
  /**
   * @description Returns a new file reference. This returns a new instance even if the path does not exist.
   * @param {string} fullPath A full path.
   * @returns {FileReference} A file reference to the specified path.
   */
  static createFromFullPath(fullPath) {  }
  /**
   * @description Returns a new file reference. This returns a new instance even if the path does not exist.
   * @param {string} fullPath A full path. This parameter cannot be null.
   * @param {string} relativePath A relative path. This parameter can be null.
   * @returns {FileReference} A file reference to the specified paths.
   */
  static createFromFullAndRelativePaths(fullPath,relativePath) {  }
  /**
   * @description Gets the absolute path of this file reference.
   * @type {string}
   */
  get fullPath() { return null;}
  /**
   * @description Gets the relative path of this file reference.
   * @type {string}
   */
  get relativePath() { return null;}
}
/**
 &lt;summary>
   Provides a common base for most geometric classes. This class is abstract.
   &lt;/summary>
 * @extends CommonObject
 * @hideconstructor
 */
class GeometryBase {
  /**
   * @description Transforms the geometry. If the input Transform has a SimilarityType of
     OrientationReversing, you may want to consider flipping the transformed
     geometry after calling this function when it makes sense. For example,
     you may want to call Flip() on a Brep after transforming it.
   * @param {Transform} xform Transformation to apply to geometry.
   * @returns {bool} true if geometry successfully transformed.
   */
  transform(xform) {  }
  /**
   * @description Translates the object along the specified vector.
   * @param {Array.&lt;x,y,z>} translationVector A moving vector.
   * @returns {bool} true if geometry successfully translated.
   */
  translate(translationVector) {  }
  /**
   * @description Scales the object by the specified factor. The scale is centered at the origin.
   * @param {double} scaleFactor The uniform scaling factor.
   * @returns {bool} true if geometry successfully scaled.
   */
  scale(scaleFactor) {  }
  /**
   * @description Rotates the object about the specified axis. A positive rotation 
     angle results in a counter-clockwise rotation about the axis (right hand rule).
   * @param {double} angleRadians Angle of rotation in radians.
   * @param {Array.&lt;x,y,z>} rotationAxis Direction of the axis of rotation.
   * @param {Array.&lt;x,y,z>} rotationCenter Point on the axis of rotation.
   * @returns {bool} true if geometry successfully rotated.
   */
  rotate(angleRadians,rotationAxis,rotationCenter) {  }
  /**
   * @description Boundingbox solver. Gets the world axis aligned boundingbox for the geometry.
   * @param {bool} accurate If true, a physically accurate boundingbox will be computed. 
     If not, a boundingbox estimate will be computed. For some geometry types there is no 
     difference between the estimate and the accurate boundingbox. Estimated boundingboxes 
     can be computed much (much) faster than accurate (or "tight") bounding boxes. 
     Estimated bounding boxes are always similar to or larger than accurate bounding boxes.
   * @returns {BoundingBox} The boundingbox of the geometry in world coordinates or BoundingBox.Empty 
     if not bounding box could be found.
   */
  getBoundingBox(accurate) {  }
  /**
   * @description If possible, converts the object into a form that can be accurately modified
     with "squishy" transformations like projections, shears, an non-uniform scaling.
   * @returns {bool} false if object cannot be converted to a deformable object. true if object was
     already deformable or was converted into a deformable object.
   */
  makeDeformable() {  }
  /**
   * @description Useful for switch statements that need to differentiate between
     basic object types like points, curves, surfaces, and so on.
   * @type {ObjectType}
   */
  get objectType() { return null;}
  /**
   * @description true if object can be accurately modified with "squishy" transformations like
     projections, shears, and non-uniform scaling.
   * @type {bool}
   */
  get isDeformable() { return null;}
  /**
   * @description Returns true if the Brep.TryConvertBrep function will be successful for this object
   * @type {bool}
   */
  get hasBrepForm() { return null;}
}
/**
 &lt;summary>
   Represents a hatch in planar boundary loop or loops.
   This is a 2d entity with a plane defining a local coordinate system.
   The loops, patterns, angles, etc are all in this local coordinate system.
   The Hatch object manages the plane and loop array
   Fill definitions are in the HatchPattern or class derived from HatchPattern
   Hatch has an index to get the pattern definition from the pattern table.
   &lt;/summary>
 * @extends GeometryBase
 */
class Hatch {
}
/**
 * Layer
 * @extends CommonObject
 */
class Layer {
  /**
   * @description Verifies that a layer has per viewport settings.
   * @param {Guid} viewportId If not Guid.Empty, then checks for settings for that specific viewport. 
     If Guid.Empty, then checks for any viewport settings.
   * @returns {bool} True if the layer has per viewport settings, false otherwise.
   */
  hasPerViewportSettings(viewportId) {  }
  /**
   * @description Deletes per viewport layer settings.
   * @param {Guid} viewportId If not Guid.Empty, then the settings for that viewport are deleted.
     If Guid.Empty, then all per viewport settings are deleted.
   */
  deletePerViewportSettings(viewportId) {  }
  /**
   * @description Gets the display color for this layer.
   * @param {Guid} viewportId If not Guid.Empty, then the setting applies only to the viewport with the specified id.
   * @returns {System.Drawing.Color} The display color.
   */
  perViewportColor(viewportId) {  }
  /**
   * @description Sets the display color for this layer.
   * @param {Guid} viewportId If not Guid.Empty, then the setting applies only to the viewport with the specified id.
   * @param {System.Drawing.Color} color The display color.
   */
  setPerViewportColor(viewportId,color) {  }
  /**
   * @description Remove any per viewport layer color setting so the layer's overall setting will be used for all viewports.
   * @param {Guid} viewportId If not Guid.Empty, then the setting for this viewport will be deleted.
     If Guid.Empty, the all per viewport layer color settings will be removed.
   */
  deletePerViewportColor(viewportId) {  }
  /**
   * @description The persistent visbility setting is used for layers whose visibilty can
     be changed by a "parent" object. A common case is when a layer is a
     child layer (ParentId is not nil). In this case, when a parent layer is
     turned off, then child layers are also turned off. The persistent
     visibility setting determines what happens when the parent is turned on
     again.
   */
  getPersistentVisibility() {  }
  /**
   * @description Set the persistent visibility setting for this layer
   */
  setPersistentVisibility() {  }
  /**
   * @description Remove any explicit persistent visibility setting from this layer
   */
  unsetPersistentVisibility() {  }
  /**
   * @description The persistent locking setting is used for layers that can be locked by
     a "parent" object. A common case is when a layer is a child layer
     (Layer.ParentI is not nil). In this case, when a parent layer is locked,
     then child layers are also locked. The persistent locking setting
     determines what happens when the parent is unlocked again.
   */
  getPersistentLocking() {  }
  /**
   * @description Set the persistent locking setting for this layer
   */
  setPersistentLocking() {  }
  /**
   * @description Remove any explicity persistent locking settings from this layer
   */
  unsetPersistentLocking() {  }
  /**
   * @description Gets or sets the name of this layer.
   * @type {string}
   */
  get name() { return null;}
  /**
   * @description Gets or sets the ID of this layer object. 
     You typically do not need to assign a custom ID.
   * @type {Guid}
   */
  get id() { return null;}
  /**
   * @description Gets the ID of the parent layer. Layers can be origanized in a hierarchical structure, 
     in which case this returns the parent layer ID. If the layer has no parent, 
     Guid.Empty will be returned.
   * @type {Guid}
   */
  get parentLayerId() { return null;}
  /**
   * @description Gets or sets the IGES level for this layer.
   * @type {int}
   */
  get igesLevel() { return null;}
  /**
   * @description Gets or sets the display color for this layer.
   * @type {System.Drawing.Color}
   */
  get color() { return null;}
  /**
   * @description Gets or sets the plot color for this layer.
   * @type {System.Drawing.Color}
   */
  get plotColor() { return null;}
  /**
   * @description Gets or sets the weight of the plotting pen in millimeters. 
     A weight of 0.0 indicates the "default" pen weight should be used.
     A weight of -1.0 indicates the layer should not be printed.
   * @type {double}
   */
  get plotWeight() { return null;}
  /**
   * @description Gets or sets the line-type index for this layer.
   * @type {int}
   */
  get linetypeIndex() { return null;}
  /**
   * @description Gets or sets the index of render material for objects on this layer that have
     MaterialSource() == MaterialFromLayer. 
     A material index of -1 indicates no material has been assigned 
     and the material created by the default Material constructor 
     should be used.
   * @type {int}
   */
  get renderMaterialIndex() { return null;}
  /**
   */
  get visible() { return null;}
  /**
   */
  get locked() { return null;}
  /**
   */
  get expanded() { return null;}
}
/**
 * Line
 */
class Line {
  /**
   * @description Constructs a new line segment between two points.
   * @param {Array.&lt;x,y,z>} from Start point of line.
   * @param {Array.&lt;x,y,z>} to End point of line.
   */
  constructor(from,to){}
  /**
   * @description Start point of line segment.
   * @type {Array.&lt;x,y,z>}
   */
  get from() { return null;}
  /**
   * @description End point of line segment.
   * @type {Array.&lt;x,y,z>}
   */
  get to() { return null;}
  /**
   * @description Gets or sets the length of this line segment. 
     Note that a negative length will invert the line segment without 
     making the actual length negative. The line From point will remain fixed 
     when a new Length is set.
   * @type {double}
   */
  get length() { return null;}
}
/**
 &lt;summary>
   Represents a linear curve.
   &lt;/summary>
 * @extends Curve
 */
class LineCurve {
  /**
   * @description Initializes a new instance of the  class, by
     setting start and end point from two 3D points.
   * @param {Array.&lt;x,y,z>} from A start point.
   * @param {Array.&lt;x,y,z>} to An end point.
   */
  constructor(from,to){}
}
/**
 * Material
 * @extends CommonObject
 */
class Material {
  /**
   * @description Set material to default settings.
   */
  default() {  }
  /** ... */
  getBitmapTexture() {  }
  /** ... */
  setBitmapTexture() {  }
  /**
   * @description Gets the bump texture of this material.
   * @returns {Texture} A texture; or null if no bump texture has been added to this material.
   */
  getBumpTexture() {  }
  /** ... */
  setBumpTexture() {  }
  /** ... */
  getEnvironmentTexture() {  }
  /** ... */
  setEnvironmentTexture() {  }
  /** ... */
  getTransparencyTexture() {  }
  /** ... */
  setTransparencyTexture() {  }
  /**
   * @description The Id of the RenderPlugIn that is associated with this material.
   * @type {Guid}
   */
  get renderPlugInId() { return null;}
  /**
   * @type {string}
   */
  get name() { return null;}
  /**
   * @description Gets or sets the shine factor of the material.
   * @type {double}
   */
  get shine() { return null;}
  /**
   * @description Gets or sets the transparency of the material (0.0 = opaque to 1.0 = transparent)
   * @type {double}
   */
  get transparency() { return null;}
  /**
   * @description Gets or sets the index of refraction of the material, generally
     >= 1.0 (speed of light in vacuum)/(speed of light in material)
   * @type {double}
   */
  get indexOfRefraction() { return null;}
  /**
   * @description Gets or sets the Fresnel index of refraction of the material,
     default is 1.56
   * @type {double}
   */
  get fresnelIndexOfRefraction() { return null;}
  /**
   * @description Gets or sets the refraction glossiness.
   * @type {double}
   */
  get refractionGlossiness() { return null;}
  /**
   * @description Gets or sets the reflection glossiness.
   * @type {double}
   */
  get reflectionGlossiness() { return null;}
  /**
   * @description Gets or sets if fresnel reflections are used.
   * @type {bool}
   */
  get fresnelReflections() { return null;}
  /**
   * @type {bool}
   */
  get disableLighting() { return null;}
  /**
   * @description Gets or sets how reflective a material is, 0f is no reflection
     1f is 100% reflective.
   * @type {double}
   */
  get reflectivity() { return null;}
  /**
   * @description Very simple preview color function for GUIs.
   * @type {System.Drawing.Color}
   */
  get previewColor() { return null;}
  /**
   * @type {System.Drawing.Color}
   */
  get diffuseColor() { return null;}
  /**
   * @type {System.Drawing.Color}
   */
  get ambientColor() { return null;}
  /**
   * @type {System.Drawing.Color}
   */
  get emissionColor() { return null;}
  /**
   * @type {System.Drawing.Color}
   */
  get specularColor() { return null;}
  /**
   * @type {System.Drawing.Color}
   */
  get reflectionColor() { return null;}
  /**
   * @type {System.Drawing.Color}
   */
  get transparentColor() { return null;}
}
/**
 * Mesh
 * @extends GeometryBase
 */
class Mesh {
  /** ... */
  vertices() {  }
  /** ... */
  faces() {  }
  /** ... */
  normals() {  }
  /** ... */
  textureCoordinates() {  }
  /**
   * @description Removes all texture coordinate information from this mesh.
   */
  clearTextureData() {  }
  /**
   * @description Removes surface parameters, curvature parameters and surface statistics from the mesh.
   */
  clearSurfaceData() {  }
  /**
   * @description Removes topology data, forcing all topology information to be recomputed.
   */
  destroyTopology() {  }
  /**
   * @description Destroys the mesh vertex access tree.
   */
  destroyTree() {  }
  /**
   * @description Destroys mesh partition.
   */
  destroyPartition() {  }
  /**
   * @description Removes any unreferenced objects from arrays, reindexes as needed 
     and shrinks arrays to minimum required size.
   * @returns {bool} true on success, false on failure.
   */
  compact() {  }
  /**
   * @description Appends a copy of another mesh to this one and updates indices of appended mesh parts.
   * @param {Mesh} other Mesh to append to this one.
   */
  append(other) {  }
  /**
   * @description In ancient times (or modern smartphone times), some rendering engines
     were only able to process small batches of triangles and the
     CreatePartitions() function was provided to partition the mesh into
     subsets of vertices and faces that those rendering engines could handle.
   * @returns {bool} true on success
   */
  createPartitions() {  }
  /**
   * @description Gets a value indicating whether a mesh is considered to be closed (solid).
     A mesh is considered solid when every mesh edge borders two or more faces.
   * @returns {bool} true if the mesh is closed, false if it is not.
   * @type {bool}
   */
  get isClosed() { return null;}
  /**
   * @description Will return true if SetCachedTextureCoordinates has been called;
     otherwise will return false.
   * @type {bool}
   */
  get hasCachedTextureCoordinates() { return null;}
  /**
   * @description Number of partition information chunks stored on this mesh based
     on the last call to CreatePartitions
   * @type {int}
   */
  get partitionCount() { return null;}
}
/**
 &lt;summary>
   Provides access to the faces and Face related functionality of a Mesh.
   &lt;/summary>
 * @hideconstructor
 */
class MeshFaceList {
  /** ... */
  get() {  }
  /**
   * @description Gets or sets the number of mesh faces. When getting this can includes invalid faces.
   * @type {int}
   */
  get count() { return null;}
}
/**
 * MeshNormalList
 * @hideconstructor
 */
class MeshNormalList {
  /** ... */
  get() {  }
  /** ... */
  set() {  }
  /**
   */
  get count() { return null;}
}
/**
 &lt;summary>
   Provides access to the Vertex Texture coordinates of a Mesh.
   &lt;/summary>
 * @hideconstructor
 */
class MeshTextureCoordinateList {
  /** ... */
  get() {  }
  /** ... */
  set() {  }
  /**
   * @description Gets or sets the number of texture coordinates.
   * @type {int}
   */
  get count() { return null;}
}
/**
 &lt;summary>
   Provides access to the vertices and vertex-related functionality of a mesh.
   &lt;/summary>
 * @hideconstructor
 */
class MeshVertexList {
  /** ... */
  setCount() {  }
  /** ... */
  get() {  }
  /** ... */
  set() {  }
  /**
   * @description Gets or sets the number of mesh vertices.
   * @type {int}
   */
  get count() { return null;}
}
/**
 &lt;summary>
   Base class for all components in a model (document) and manages the
   index, id and other information common to this type of objects.
   &lt;para>This class parallels the C++ ON_ModelComponent.&lt;/para>
   &lt;/summary>
 * @extends CommonObject
 * @hideconstructor
 */
class ModelComponent {
}
/**
 &lt;summary>
   Represents a Non Uniform Rational B-Splines (NURBS) curve.
   &lt;/summary>
 * @extends Curve
 */
class NurbsCurve {
  /**
   * @description Constructs a new NURBS curve with a specific degree and control point count.
   * @param {int} degree Degree of curve. Must be equal to or larger than 1 and smaller than or equal to 11.
   * @param {int} pointCount Number of control-points.
   */
  constructor(degree,pointCount){}
  /**
   * @description Constructs a new NURBS curve with knot and CV memory allocated.
   * @param {int} dimension >=1.
   * @param {bool} rational true to make a rational NURBS.
   * @param {int} order (>= 2) The order=degree+1.
   * @param {int} pointCount (>= order) number of control vertices.
   */
  static createFromLine() {  }
  /**
   * @description Gets a rational degree 2 NURBS curve representation
     of the arc. Note that the parameterization of NURBS curve
     does not match arc's transcendental paramaterization.
   * @returns {NurbsCurve} Curve on success, null on failure.
   */
  static createFromArc() {  }
  /**
   * @description Gets a rational degree 2 NURBS curve representation
     of the circle. Note that the parameterization of NURBS curve
     does not match circle's transcendental paramaterization.  
     Use GetRadianFromNurbFormParameter() and
     GetParameterFromRadian() to convert between the NURBS curve 
     parameter and the transcendental parameter.
   * @returns {NurbsCurve} Curve on success, null on failure.
   */
  static createFromCircle() {  }
  /**
   * @description Gets a rational degree 2 NURBS curve representation of the ellipse.
     Note that the parameterization of the NURBS curve does not match
     with the transcendental paramaterization of the ellipsis.
   * @returns {NurbsCurve} A nurbs curve representation of this ellipse or null if no such representation could be made.
   */
  static createFromEllipse() {  }
  /**
   * @description Constructs a 3D NURBS curve from a list of control points.
   * @param {bool} periodic If true, create a periodic uniform curve. If false, create a clamped uniform curve.
   * @param {int} degree (>=1) degree=order-1.
   * @param {System.Collections.Generic.IEnumerable&lt;Point3d>} points control vertex locations.
   * @returns {NurbsCurve} new NURBS curve on success
     null on error.
   */
  static create(periodic,degree,points) {  }
  /**
   * @description Increase the degree of this curve.
   * @param {int} desiredDegree The desired degree. 
     Degrees should be number between and including 1 and 11.
   * @returns {bool} true on success, false on failure.
   */
  increaseDegree(desiredDegree) {  }
  /**
   * @description Clamps ends and adds knots so the NURBS curve has bezier spans 
     (all distinct knots have multiplitity = degree).
   * @param {bool} setEndWeightsToOne If true and the first or last weight is not one, then the first and
     last spans are reparameterized so that the end weights are one.
   * @returns {bool} true on success, false on failure.
   */
  makePiecewiseBezier(setEndWeightsToOne) {  }
  /**
   * @description Use a linear fractional transformation to reparameterize the NURBS curve.
     This does not change the curve's domain.
   * @param {double} c reparameterization constant (generally speaking, c should be > 0). The
     control points and knots are adjusted so that
     output_nurbs(t) = input_nurbs(lambda(t)), where lambda(t) = c*t/( (c-1)*t + 1 ).
     Note that lambda(0) = 0, lambda(1) = 1, lambda'(t) > 0, 
     lambda'(0) = c and lambda'(1) = 1/c.
   * @returns {bool} true if successful.
   */
  reparameterize(c) {  }
  /**
   * @description Gets the greville (edit point) parameter that belongs 
     to the control point at the specified index.
   * @param {int} index Index of Greville (Edit) point.
   */
  grevilleParameter(index) {  }
  /**
   * @description Gets the greville (edit point) parameter that belongs 
     to the control point at the specified index.
   * @param {int} index Index of Greville (Edit) point.
   */
  grevillePoint(index) {  }
  /**
   * @description Gets the order of the curve. Order = Degree + 1.
   * @type {int}
   */
  get order() { return null;}
  /**
   * @description Gets a value indicating whether or not the curve is rational. 
     Rational curves have control-points with custom weights.
   * @type {bool}
   */
  get isRational() { return null;}
  /**
   * @description Returns true if the NURBS curve has bezier spans (all distinct knots have multiplitity = degree)
   * @type {bool}
   */
  get hasBezierSpans() { return null;}
}
/**
 &lt;summary>
   Provides access to the knot vector of a nurbs curve.
   &lt;/summary>
 * @hideconstructor
 */
class NurbsCurveKnotList {
  /** ... */
  get() {  }
  /** ... */
  set() {  }
  /**
   * @description Inserts a knot and update control point locations.
     Does not change parameterization or locus of curve.
   * @param {double} value Knot value to insert.
   * @returns {bool} true on success, false on failure.
   */
  insertKnot(value) {  }
  /**
   * @description Get knot multiplicity.
   * @param {int} index Index of knot to query.
   * @returns {int} The multiplicity (valence) of the knot.
   */
  knotMultiplicity(index) {  }
  /**
   * @description Compute a clamped, uniform knot vector based on the current
     degree and control point count. Does not change values of control
     vertices.
   * @param {double} knotSpacing Spacing of subsequent knots.
   * @returns {bool} true on success, false on failure.
   */
  createUniformKnots(knotSpacing) {  }
  /**
   * @description Compute a clamped, uniform, periodic knot vector based on the current
     degree and control point count. Does not change values of control
     vertices.
   * @param {double} knotSpacing Spacing of subsequent knots.
   * @returns {bool} true on success, false on failure.
   */
  createPeriodicKnots(knotSpacing) {  }
  /**
   * @description Computes the knots that are superfluous because they are not used in NURBs evaluation.
     These make it appear so that the first and last curve spans are different from interior spans.
     http://wiki.mcneel.com/developer/onsuperfluousknot
   * @param {bool} start true if the query targets the first knot. Otherwise, the last knot.
   * @returns {double} A component.
   */
  superfluousKnot(start) {  }
  /**
   * @description Total number of knots in this curve.
   * @type {int}
   */
  get count() { return null;}
  /**
   * @description Gets a value indicating whether or not the knot vector is clamped at the start of the curve. 
     Clamped curves start at the first control-point. This requires fully multiple knots.
   * @type {bool}
   */
  get isClampedStart() { return null;}
  /**
   * @description Gets a value indicating whether or not the knot vector is clamped at the end of the curve. 
     Clamped curves are coincident with the first and last control-point. This requires fully multiple knots.
   * @type {bool}
   */
  get isClampedEnd() { return null;}
}
/**
 &lt;summary>
   Provides access to the control points of a nurbs curve.
   &lt;/summary>
 * @hideconstructor
 */
class NurbsCurvePointList {
  /** ... */
  get() {  }
  /** ... */
  set() {  }
  /**
   * @description Use a combination of scaling and reparameterization to change the end weights to the specified values.
   * @param {double} w0 Weight for first control point.
   * @param {double} w1 Weight for last control point.
   * @returns {bool} true on success, false on failure.
   */
  changeEndWeights(w0,w1) {  }
  /**
   * @description Converts the curve to a Rational NURBS curve. Rational NURBS curves have weighted control points.
   * @returns {bool} true on success, false on failure.
   */
  makeRational() {  }
  /**
   * @description Converts the curve to a Non-rational NURBS curve. Non-rational curves have unweighted control points.
   * @returns {bool} true on success, false on failure.
   */
  makeNonRational() {  }
  /**
   * @description Gets the number of control points in this curve.
   * @type {int}
   */
  get count() { return null;}
  /**
   * @description Gets the length of the polyline connecting all control points.
   * @type {double}
   */
  get controlPolygonLength() { return null;}
}
/**
 &lt;summary>
   Represents a Non Uniform Rational B-Splines (NURBS) surface.
   &lt;/summary>
 * @extends Surface
 * @hideconstructor
 */
class NurbsSurface {
  /**
   * @description Constructs a ruled surface between two curves. Curves must share the same knot-vector.
   * @param {Curve} curveA First curve.
   * @param {Curve} curveB Second curve.
   * @returns {NurbsSurface} A ruled surface on success or null on failure.
   */
  static createRuledSurface(curveA,curveB) {  }
  /**
   * @description Makes this surface rational.
   * @returns {bool} true if the operation succeeded; otherwise, false.
   */
  makeRational() {  }
  /**
   * @description Makes this surface non-rational.
   * @returns {bool} true if the operation succeeded; otherwise, false.
   */
  makeNonRational() {  }
  /**
   * @description Increase the degree of this surface in U direction.
   * @param {int} desiredDegree The desired degree. 
     Degrees should be number between and including 1 and 11.
   * @returns {bool} true on success, false on failure.
   */
  increaseDegreeU(desiredDegree) {  }
  /**
   * @description Increase the degree of this surface in V direction.
   * @param {int} desiredDegree The desired degree. 
     Degrees should be number between and including 1 and 11.
   * @returns {bool} true on success, false on failure.
   */
  increaseDegreeV(desiredDegree) {  }
  /**
   * @description Gets a value indicating whether or not the nurbs surface is rational.
   * @type {bool}
   */
  get isRational() { return null;}
  /**
   * @description Gets the order in the U direction.
   * @type {int}
   */
  get orderU() { return null;}
  /**
   * @description Gets the order in the V direction.
   * @type {int}
   */
  get orderV() { return null;}
}
/**
 &lt;summary>
   Attributes (color, material, layer,...) associated with a rhino object
   &lt;/summary>
 * @extends CommonObject
 */
class ObjectAttributes {
  /**
   * @description Apply a transformation.
   * @param {Transform} xform The transformation.
   * @returns {bool} trueif successful, false otherwise.
   */
  transform(xform) {  }
  /**
   * @description Determines if an object has a display mode override for a given viewport.
   * @param {Guid} viewportId Id of a Rhino Viewport.
   * @returns {bool} true if the object has a display mode override for the viewport; otherwise, false.
   */
  hasDisplayModeOverride(viewportId) {  }
  /**
   * @description Adds object to the group with specified index by appending index to
     group list.
     If the object is already in group, nothing is changed.
   * @param {int} groupIndex The index that will be added.
   */
  addToGroup(groupIndex) {  }
  /**
   * @description removes object from the group with specified index.
     If the object is not in the group, nothing is changed.
   * @param {int} groupIndex The index that will be removed.
   */
  removeFromGroup(groupIndex) {  }
  /**
   * @description Removes object from all groups.
   */
  removeFromAllGroups() {  }
  /**
   * @description An object must be in one of three modes: normal, locked or hidden.
     If an object is in normal mode, then the object's layer controls visibility
     and selectability. If an object is locked, then the object's layer controls
     visibility by the object cannot be selected. If the object is hidden, it is
     not visible and it cannot be selected.
   * @type {ObjectMode}
   */
  get mode() { return null;}
  /**
   * @description Use this query to determine if an object is part of an instance definition.
   * @type {bool}
   */
  get isInstanceDefinitionObject() { return null;}
  /**
   * @description Gets or sets an object's visiblity.
   * @type {bool}
   */
  get visible() { return null;}
  /**
   * @description Gets or sets an object optional text name.
     More than one object in a model can have the same name and
     some objects may have no name.
   * @type {string}
   */
  get name() { return null;}
  /**
   * @description Gets or sets an object's casts shadows property, or whether or not an object casts shadows on other objects and a ground plane.
   * @type {bool}
   */
  get castsShadows() { return null;}
  /**
   * @description Gets or sets an object's receives shadows property, or whether or not an object receives shadows from other objects.
   * @type {bool}
   */
  get receivesShadows() { return null;}
  /**
   * @description The Linetype used to display an object is specified in one of two ways.
     If LinetypeSource is ON::linetype_from_layer, then the object's layer ON_Layer::Linetype() is used.
     If LinetypeSource is ON::linetype_from_object, then value of m_linetype is used.
   * @type {ObjectLinetypeSource}
   */
  get linetypeSource() { return null;}
  /**
   * @description The color used to display an object is specified in one of three ways.
     If ColorSource is ON::color_from_layer, then the object's layer ON_Layer::Color() is used.
     If ColorSource is ON::color_from_object, then value of m_color is used.
     If ColorSource is ON::color_from_material, then the diffuse color of the object's
     render material is used.  See ON_3dmObjectAttributes::MaterialSource() to
     determine where to get the definition of the object's render material.
   * @type {ObjectColorSource}
   */
  get colorSource() { return null;}
  /**
   * @description The color used to plot an object on paper is specified in one of three ways.
     If PlotColorSource is ON::plot_color_from_layer, then the object's layer ON_Layer::PlotColor() is used.
     If PlotColorSource is ON::plot_color_from_object, then value of PlotColor() is used.
   * @type {ObjectPlotColorSource}
   */
  get plotColorSource() { return null;}
  /**
   * @type {ObjectPlotWeightSource}
   */
  get plotWeightSource() { return null;}
  /**
   */
  get id() { return null;}
  /**
   * @description Gets or sets an object optional text name.
     More than one object in a model can have the same name and
     some objects may have no name.
   * @type {string}
   */
  get name() { return null;}
  /**
   * @description Objects may have an URL. There are no restrictions on what value this
     URL may have. As an example, if the object came from a commercial part
     library, the URL might point to the definition of that part.
   * @type {string}
   */
  get url() { return null;}
  /**
   * @description Gets or sets an associated layer index.
     Layer definitions in an OpenNURBS model are stored in a layer table.
     The layer table is conceptually an array of ON_Layer classes.  Every
     OpenNURBS object in a model is on some layer.  The object's layer
     is specified by zero based indicies into the ON_Layer array.
   * @type {int}
   */
  get layerIndex() { return null;}
  /**
   * @description Gets or sets the material index.
     If you want something simple and fast, set the index of
     the rendering material.
   * @type {int}
   */
  get materialIndex() { return null;}
  /**
   * @description Determines if the simple material should come from the object or from it's layer.
     High quality rendering plug-ins should use m_rendering_attributes.
   * @type {ObjectMaterialSource}
   */
  get materialSource() { return null;}
  /**
   * @description If ON::color_from_object == ColorSource, then color is the object's display color.
   * @type {System.Drawing.Color}
   */
  get objectColor() { return null;}
  /**
   * @description If plot_color_from_object == PlotColorSource, then PlotColor is the object's plotting color.
   * @type {System.Drawing.Color}
   */
  get plotColor() { return null;}
  /**
   * @description Display order used to force objects to be drawn on top or behind each other.
     Larger numbers draw on top of smaller numbers.
     0  = draw object in standard depth buffered order&lt;0 = draw object behind "normal" draw order objects>0 = draw object on top of "normal" draw order objects
   * @type {int}
   */
  get displayOrder() { return null;}
  /**
   * @description Plot weight in millimeters.
     =0.0 means use the default width
     &lt;0.0 means don't plot (visible for screen display, but does not show on plot)
   * @type {double}
   */
  get plotWeight() { return null;}
  /**
   * @description Used to indicate an object has a decoration (like an arrowhead on a curve)
   * @type {ObjectDecoration}
   */
  get objectDecoration() { return null;}
  /**
   * @description When a surface object is displayed in wireframe, this controls
     how many isoparametric wires are used.
     value    number of isoparametric wires
     -1       boundary wires (off)
     0        boundary and knot wires 
     1        boundary and knot wires and, if there are no interior knots, a single interior wire.
     N>=2     boundary and knot wires and (N+1) interior wires.
   * @type {int}
   */
  get wireDensity() { return null;}
  /**
   * @description If ViewportId is nil, the object is active in all viewports. If ViewportId is not nil, then 
     this object is only active in a specific view. This field is primarily used to assign page
     space objects to a specific page, but it can also be used to restrict model space to a
     specific view.
   * @type {Guid}
   */
  get viewportId() { return null;}
  /**
   */
  get activeSpace() { return null;}
  /**
   * @description number of groups object belongs to.
   * @type {int}
   */
  get groupCount() { return null;}
}
/**
 &lt;summary>
   Represents a plane surface, with plane and two intervals.
   &lt;/summary>
 * @extends Surface
 */
class PlaneSurface {
}
/**
 &lt;summary>
   Represents a geometric point.
   &lt;para>This is fundamentally a class that derives from
   &lt;see cref="GeometryBase"/> and contains a single &lt;see cref="Point3d"/> location.&lt;/para>
   &lt;/summary>
 * @extends GeometryBase
 */
class Point {
}
/**
 * Point3d
 * @hideconstructor
 */
class Point3d {
  /**
   * @description Transforms the present point in place. The transformation matrix acts on the left of the point. i.e.,
     result = transformation*point
   * @param {Transform} xform Transformation to apply.
   */
  static transform(xform) {  }
}
/**
 &lt;summary>
   Represents a list of &lt;see cref="Point3d"/>.
   &lt;/summary>
 */
class Point3dList {
  /**
   * @description Initializes a new point list with a preallocated initial capacity.
   * @param {int} initialCapacity The number of added items before which the underlying array will be resized.
   */
  constructor(initialCapacity){}
  /** ... */
  get() {  }
  /** ... */
  set() {  }
  /** ... */
  clear() {  }
  /** ... */
  insert() {  }
  /** ... */
  removeAt() {  }
  /**
   * @description Adds a Point3d to the end of the list with given x,y,z coordinates.
   * @param {double} x The X coordinate.
   * @param {double} y The Y coordinate.
   * @param {double} z The Z coordinate.
   */
  add(x,y,z) {  }
  /**
   * @description Applies a transform to all the points in the list.
   * @param {Transform} xform Transform to apply.
   */
  transform(xform) {  }
  /**
   * @description Set all the X values for the points to a single value
   */
  setAllX() {  }
  /**
   * @description Set all the Y values for the points to a single value
   */
  setAllY() {  }
  /**
   * @description Set all the Z values for the points to a single value
   */
  setAllZ() {  }
  /**
   */
  get capacity() { return null;}
  /**
   */
  get count() { return null;}
  /**
   * @description Even though this is a property, it is not a "fast" calculation. Every point is
     evaluated in order to get the bounding box of the list.
   * @type {BoundingBox}
   */
  get boundingBox() { return null;}
}
/**
 &lt;summary>
   Represents a collection of coordinates with optional normal vectors and colors.
   &lt;/summary>
 * @extends GeometryBase
 */
class PointCloud {
}
/**
 * PointGrid
 * @extends GeometryBase
 */
class PointGrid {
}
/**
 &lt;summary>
   Represents a curve that is the result of joining several (possibly different)
   types of curves.
   &lt;/summary>
 * @extends Curve
 * @hideconstructor
 */
class Polycurve {
}
/**
 &lt;summary>
   Represents an ordered set of points connected by linear segments.
   &lt;para>Polylines are closed if start and end points coincide.&lt;/para>
   &lt;/summary>
 * @extends Point3dList
 */
class Polyline {
  /**
   * @description Initializes a new empty polyline with an initial capacity.
   * @param {int} initialCapacity Number of vertices this polyline can contain without resizing.
   */
  constructor(initialCapacity){}
  /**
   * @description Determines whether the polyline is closed, provided a tolerance value.
   * @param {double} tolerance If the distance between the start and end point of the polyline 
     is less than tolerance, the polyline is considered to be closed.
   * @returns {bool} true if the polyline is closed to within tolerance, false otherwise.
   */
  isClosedWithinTolerance(tolerance) {  }
  /**
   * @description Gets the point on the polyline at the given parameter. 
     The integer part of the parameter indicates the index of the segment.
   * @param {double} t Polyline parameter.
   * @returns {Array.&lt;x,y,z>} The point on the polyline at t.
   */
  pointAt(t) {  }
  /**
   * @description Gets the unit tangent vector along the polyline at the given parameter. 
     The integer part of the parameter indicates the index of the segment.
   * @param {double} t Polyline parameter.
   * @returns {Array.&lt;x,y,z>} The tangent along the polyline at t.
   */
  tangentAt(t) {  }
  /** ... */
  closesPoint() {  }
  /**
   * @description Gets the parameter along the polyline which is closest to a test-point.
   * @param {Array.&lt;x,y,z>} testPoint Point to approximate.
   * @returns {double} The parameter along the polyline closest to testPoint.
   */
  closestParameter(testPoint) {  }
  /**
   * @description Constructs a nurbs curve representation of this polyline.
   * @returns {NurbsCurve} A Nurbs curve shaped like this polyline or null on failure.
   */
  toNurbsCurve() {  }
  /**
   * @description Constructs a polyline curve representation of this polyline.
   * @returns {PolylineCurve} A curve shaped like this polyline or null on failure.
   */
  toPolylineCurve() {  }
  /**
   * @description Create a regular polygon inscribed in a circle. The vertices of the polygon will be on the circle.
   * @param {Circle} circle The circle.
   * @param {int} sideCount The number of sides
   * @returns {Polyline} A closed polyline if successful, null otherwise.
   */
  static createInscribedPolygon(circle,sideCount) {  }
  /**
   * @description Create a regular polygon circumscribe about a circle. The midpoints of the polygon's edges will be tanget to the circle.
   * @param {Circle} circle The circle.
   * @param {int} sideCount The number of sides
   * @returns {Polyline} A closed polyline if successful, null otherwise.
   */
  static createCircumscribedPolygon(circle,sideCount) {  }
  /**
   * @description Create a regular star polygon. The star begins at circle.PointAt(0) and the vertices
     alternate between being on circle and begin on a concentric circle of other_radius.
   * @param {Circle} circle The circle.
   * @param {double} radius The radius of other circle.
   * @param {int} cornerCount The number of corners on the circle. There will be 2*cornerCount sides and 2*cornerCount vertices.
   * @returns {Polyline} A closed polyline if successful, null otherwise.
   */
  static createStarPolygon(circle,radius,cornerCount) {  }
  /**
   * @description Gets a value that indicates whether this polyline is valid. 
     Valid polylines have at least one segment, no Invalid points and no zero length segments.Closed polylines with only two segments are also not considered valid.
   * @type {bool}
   */
  get isValid() { return null;}
  /**
   * @description Gets the number of segments for this polyline.
   * @type {int}
   */
  get segmentCount() { return null;}
  /**
   * @description Gets a value that indicates whether this polyline is closed. 
     The polyline is considered to be closed if its start is 
     identical to its endpoint.
   * @type {bool}
   */
  get isClosed() { return null;}
  /**
   * @description Gets the total length of the polyline.
   * @type {double}
   */
  get length() { return null;}
}
/**
 &lt;summary>
   Represents the geometry of a set of linked line segments.
   &lt;para>This is fundamentally a class that derives from &lt;see cref="Curve"/>
   and internally contains a &lt;see cref="Polyline"/>.&lt;/para>
   &lt;/summary>
 * @extends Curve
 */
class Polylinecurve {
  /**
   * @description Gets a point at a specified index in the polyline curve.
   * @param {int} index An index.
   * @returns {Array.&lt;x,y,z>} A point.
   */
  point(index) {  }
  /**
   * @description Sets a point at a specified index in the polyline curve.
   * @param {int} index An index.
   * @param {Array.&lt;x,y,z>} point A point location to set.
   */
  setPoint(index,point) {  }
  /**
   * @description Returns the underlying Polyline, or points.
   * @returns {Polyline} The Polyline if successful, null of the curve has no points.
   */
  ToPolyline() {  }
  /**
   * @description Gets the number of points in this polyline.
   * @type {int}
   */
  get pointCount() { return null;}
}
/**
 &lt;summary>
   Represents a surface of revolution.
   &lt;para>Revolutions can be incomplete (they can form arcs).&lt;/para>
   &lt;/summary>
 * @extends Surface
 */
class RevSurface {
}
/**
 * Sphere
 */
class Sphere {
  /**
   * @description Initializes a new sphere given center point and radius.
   * @param {Array.&lt;x,y,z>} center A center point.
   * @param {double} radius A radius value.
   */
  constructor(center,radius){}
  /**
   * @description Computes the parallel at a specific latitude angle.
     The angle is specified in radians.
   * @param {double} radians An angle in radians for the parallel.
   * @returns {Circle} A circle.
   */
  latitudeRadians(radians) {  }
  /**
   * @description Computes the parallel at a specific latitude angle.
     The angle is specified in degrees.
   * @param {double} degrees An angle in degrees for the meridian.
   * @returns {Circle} A circle.
   */
  latitudeDegrees(degrees) {  }
  /**
   * @description Computes the meridian at a specific longitude angle.
     The angle is specified in radians.
   * @param {double} radians An angle in radians.
   * @returns {Circle} A circle.
   */
  longitudeRadians(radians) {  }
  /** ... */
  longitureDegrees() {  }
  /**
   * @description Evaluates the sphere at specific longitude and latitude angles.
   * @param {double} longitudeRadians A number within the interval [0, 2pi].
   * @param {double} latitudeRadians A number within the interval [-pi/2,pi/2].
   * @returns {Array.&lt;x,y,z>} A point value.
   */
  pointAt(longitudeRadians,latitudeRadians) {  }
  /**
   * @description Computes the normal at a specific angular location on the sphere.
   * @param {double} longitudeRadians A number within the interval [0, 2pi].
   * @param {double} latitudeRadians A number within the interval [-pi/2, pi/2].
   * @returns {Array.&lt;x,y,z>} A vector.
   */
  normalAt(longitudeRadians,latitudeRadians) {  }
  /**
   * @description Returns point on sphere that is closest to given point.
   * @param {Array.&lt;x,y,z>} testPoint Point to project onto Sphere.
   * @returns {Array.&lt;x,y,z>} Point on sphere surface closest to testPoint.
   */
  closestPoint(testPoint) {  }
  /**
   * @description Converts this sphere is it Brep representation
   */
  toBrep() {  }
  /**
   * @description Converts this sphere to its NurbsSurface representation. 
     This is synonymous with calling NurbsSurface.CreateFromSphere().
   * @returns {NurbsSurface} A nurbs surface representation of this sphere or null.
   */
  toNurbsSurface() {  }
  /** ... */
  encode() {  }
  /** ... */
  toJSON() {  }
  /** ... */
  static decode() {  }
  /**
   * @description Gets a value that indicates whether the sphere is valid.
   * @type {bool}
   */
  get isValid() { return null;}
  /**
   * @description Gets or sets the diameter for this sphere.
   * @type {double}
   */
  get diameter() { return null;}
  /**
   * @description Gets or sets the Radius for this sphere.
   * @type {double}
   */
  get radius() { return null;}
  /**
   * @description Gets or sets the center point of the sphere.
   * @type {Array.&lt;x,y,z>}
   */
  get center() { return null;}
  /**
   * @description Gets the point at the North Pole of the sphere.
     This is the parameterization singularity that can be obtained,
     at V value +Math.Pi/2.
   * @type {Array.&lt;x,y,z>}
   */
  get northPole() { return null;}
  /**
   * @description Gets the point at the South Pole of the sphere.
     This is the parameterization singularity that can be obtained,
     at V value -Math.Pi/2.
   * @type {Array.&lt;x,y,z>}
   */
  get southPole() { return null;}
}
/**
 &lt;summary>
   Represents a base class that is common to most RhinoCommon surface types.
   &lt;para>A surface represents an entity that can be all visited by providing
   two independent parameters, usually called (u, v), or sometimes (s, t).&lt;/para>
   &lt;/summary>
 * @extends GeometryBase
 * @hideconstructor
 */
class Surface {
  /**
   * @description Returns the maximum algebraic degree of any span
     (or a good estimate if curve spans are not algebraic).
   * @param {int} direction 0 gets first parameter's domain, 1 gets second parameter's domain.
   * @returns {int} The maximum degree.
   */
  degree(direction) {  }
  /**
   * @description Gets number of smooth nonempty spans in the parameter direction.
   * @param {int} direction 0 gets first parameter's domain, 1 gets second parameter's domain.
   * @returns {int} The span count.
   */
  spanCount(direction) {  }
  /**
   * @description Evaluates a point at a given parameter.
   * @param {double} u evaluation parameters.
   * @param {double} v evaluation parameters.
   * @returns {Array.&lt;x,y,z>} Point3d.Unset on failure.
   */
  pointAt(u,v) {  }
  /**
   * @description Computes the surface normal at a point.
     This is the simple evaluation call - it does not support error handling.
   * @param {double} u A U parameter.
   * @param {double} v A V parameter.
   * @returns {Array.&lt;x,y,z>} The normal.
   */
  normalAt(u,v) {  }
  /**
   * @description Gets a value indicating if the surface is closed in a direction.
   * @param {int} direction 0 = U, 1 = V.
   * @returns {bool} The indicating boolean value.
   */
  isClosed(direction) {  }
  /**
   * @description Gets a value indicating if thr surface is periodic in a direction (default is false).
   * @param {int} direction 0 = U, 1 = V.
   * @returns {bool} The indicating boolean value.
   */
  isPeriodic(direction) {  }
  /**
   * @description true if surface side is collapsed to a point.
   * @param {int} side side of parameter space to test
     0 = south, 1 = east, 2 = north, 3 = west.
   * @returns {bool} True if this specific side of the surface is singular; otherwise, false.
   */
  isSingular(side) {  }
  /**
   * @description Tests if a surface parameter value is at a singularity.
   * @param {double} u Surface u parameter to test.
   * @param {double} v Surface v parameter to test.
   * @param {bool} exact If true, test if (u,v) is exactly at a singularity.
     If false, test if close enough to cause numerical problems.
   * @returns {bool} true if surface is singular at (s,t)
   */
  isAtSingularity(u,v,exact) {  }
  /**
   * @description Tests if a surface parameter value is at a seam.
   * @param {double} u Surface u parameter to test.
   * @param {double} v Surface v parameter to test.
   * @returns {int} 0 if not a seam,
     1 if u == Domain(0)[i] and srf(u, v) == srf(Domain(0)[1-i], v)
     2 if v == Domain(1)[i] and srf(u, v) == srf(u, Domain(1)[1-i])
     3 if 1 and 2 are true.
   */
  isAtSeam(u,v) {  }
  /**
   * @description Tests a surface to see if it is planar to zero tolerance.
   * @returns {bool} true if the surface is planar (flat) to within RhinoMath.ZeroTolerance units (1e-12).
   */
  isPlanar() {  }
  /**
   * @description Determines if the surface is a portion of a sphere within RhinoMath.ZeroTolerance.
   * @returns {bool} true if the surface is a portion of a sphere.
   */
  isSphere() {  }
  /**
   * @description Determines if the surface is a portion of a cylinder within RhinoMath.ZeroTolerance.
   * @returns {bool} true if the surface is a portion of a cylinder.
   */
  isCylinder() {  }
  /**
   * @description Determines if the surface is a portion of a cone within RhinoMath.ZeroTolerance.
   * @returns {bool} true if the surface is a portion of a cone.
   */
  isCone() {  }
  /**
   * @description Determines if the surface is a portion of a torus within RhinoMath.ZeroTolerance.
   * @returns {bool} true if the surface is a portion of a torus.
   */
  isTorus() {  }
  /**
   * @description Gets a values indicating whether a surface is solid.
   * @type {bool}
   */
  get isSolid() { return null;}
}
/**
 &lt;summary>
   Provides a base class to brep faces and other surface proxies.
   &lt;/summary>
 * @extends Surface
 * @hideconstructor
 */
class SurfaceProxy {
}
/**
 &lt;summary>
   Represents a texture that is mapped on objects.
   &lt;/summary>
 */
class Texture {
  /** ... */
  fileReference() {  }
  /**
   * @description Gets or sets a file name that is used by this texture.
     NOTE: We are moving away from string-based FileName, and suggest
     the usage of the new FileReference class.Also, this filename may well not be a path that makes sense
     on a user's computer because it was a path initially set on
     a different user's computer. If you want to get a workable path
     for this user, use the BitmapTable.Find function using this
     property.
   * @type {string}
   */
  get fileName() { return null;}
}
/**
 &lt;summary>
   Represents a texture mapping.
   &lt;/summary>
 * @extends CommonObject
 */
class TextureMapping {
  /** ... */
  static createSurfaceParameterMapping() {  }
  /**
   * @description Create a planar UV projection texture mapping
   * @param {Plane} plane A plane to use for mapping.
   * @param {Interval} dx portion of the plane's x axis that is mapped to [0,1] (can be a decreasing interval)
   * @param {Interval} dy portion of the plane's y axis that is mapped to [0,1] (can be a decreasing interval)
   * @param {Interval} dz portion of the plane's z axis that is mapped to [0,1] (can be a decreasing interval)
   * @returns {TextureMapping} TextureMapping instance if input is valid
   */
  static createPlaneMapping(plane,dx,dy,dz) {  }
  /**
   * @description Create a cylindrical projection texture mapping.
   * @param {Cylinder} cylinder cylinder in world space used to define a cylindrical coordinate system.
     The angular parameter maps (0,2pi) to texture "u" (0,1), The height
     parameter maps (height[0],height[1]) to texture "v" (0,1), and the
     radial parameter maps (0,r) to texture "w" (0,1).
   * @param {bool} capped If true, the cylinder is treated as a finite capped cylinder
   * @returns {TextureMapping} TextureMapping instance if input is valid
   */
  static createCylinderMapping(cylinder,capped) {  }
  /**
   * @description Create a spherical projection texture mapping.
   * @param {Sphere} sphere sphere in world space used to define a spherical coordinate system.
     The longitude parameter maps (0,2pi) to texture "u" (0,1).
     The latitude paramter maps (-pi/2,+pi/2) to texture "v" (0,1).
     The radial parameter maps (0,r) to texture "w" (0,1).
   * @returns {TextureMapping} TextureMapping instance if input is valid
   */
  static createSphereMapping(sphere) {  }
  /**
   * @description Create a box projection texture mapping.
   * @param {Plane} plane The sides of the box the box are parallel to the plane's coordinate
     planes.  The dx, dy, dz intervals determine the location of the sides.
   * @param {Interval} dx Determines the location of the front and back planes. The vector
     plane.xaxis is perpendicular to these planes and they pass through
     plane.PointAt(dx[0],0,0) and plane.PointAt(dx[1],0,0), respectivly.
   * @param {Interval} dy Determines the location of the left and right planes. The vector
     plane.yaxis is perpendicular to these planes and they pass through
     plane.PointAt(0,dy[0],0) and plane.PointAt(0,dy[1],0), respectivly.
   * @param {Interval} dz Determines the location of the top and bottom planes. The vector
     plane.zaxis is perpendicular to these planes and they pass through
     plane.PointAt(0,0,dz[0]) and plane.PointAt(0,0,dz[1]), respectivly.
   * @param {bool} capped If true, the box is treated as a finite capped box.
   * @returns {TextureMapping} TextureMapping instance if input is valid
   */
  static CreateBoxMapping(plane,dx,dy,dz,capped) {  }
  /**
   * @description Get a cylindrical projection parameters from this texture mapping.
   * @returns {bool} Returns true if a valid cylinder is returned.
   */
  tryGetMappingCylinder() {  }
  /**
   * @description Get a spherical projection parameters from this texture mapping.
   * @returns {bool} Returns true if a valid sphere is returned.
   */
  tryGetMappingSphere() {  }
  /** ... */
  reverseTextureCoordinate() {  }
  /** ... */
  swapTextureCoordinate() {  }
  /** ... */
  tileTextureCoordinate() {  }
  /** ... */
  evaluate() {  }
  /**
   */
  get requiresVertexNormals() { return null;}
  /**
   */
  get isPeriodic() { return null;}
}
/**
 * Transform
 */
class Transform {
  /**
   * @description Initializes a new transform matrix with a specified value along the diagonal.
   * @param {double} diagonalValue Value to assign to all diagonal cells except M33 which is set to 1.0.
   */
  constructor(diagonalValue){}
  /** ... */
  static identity() {  }
  /**
   * @description Constructs a new translation (move) transformation.
   * @param {Array.&lt;x,y,z>} motion Translation (motion) vector.
   * @returns {Transform} A transform matrix which moves geometry along the motion vector.
   */
  static translation(motion) {  }
  /**
   * @description Constructs a new uniform scaling transformation with a specified scaling anchor point.
   * @param {Array.&lt;x,y,z>} anchor Defines the anchor point of the scaling operation.
   * @param {double} scaleFactor Scaling factor in all directions.
   * @returns {Transform} A transform matrix which scales geometry uniformly around the anchor point.
   */
  static scale(anchor,scaleFactor) {  }
  /**
   * @description Constructs a new rotation transformation with specified angle, rotation center and rotation axis.
   * @param {double} sinAngle Sin of the rotation angle.
   * @param {double} cosAngle Cos of the rotation angle.
   * @param {Array.&lt;x,y,z>} rotationAxis Axis direction of rotation.
   * @param {Array.&lt;x,y,z>} rotationCenter Center point of rotation.
   * @returns {Transform} A transformation matrix which rotates geometry around an anchor point.
   */
  static rotation(sinAngle,cosAngle,rotationAxis,rotationCenter) {  }
  /** ... */
  determinant() {  }
  /**
   * @description Flip row/column values
   */
  transpose() {  }
  /**
   * @description Return true if this Transform is the identity transform
   * @type {bool}
   */
  get isIdentity() { return null;}
  /**
   * @description Gets a value indicating whether or not this Transform is a valid matrix. 
     A valid transform matrix is not allowed to have any invalid numbers.
   * @type {bool}
   */
  get isValid() { return null;}
  /**
   * @description True if matrix is Zero4x4, ZeroTransformation, or some other type of
     zero.The value xform[3][3] can be anything.
   * @type {bool}
   */
  get isZero() { return null;}
  /**
   * @description True if all values are 0
   * @type {bool}
   */
  get isZero4x4() { return null;}
  /**
   * @description True if all values are 0 and M33 is 1
   * @type {bool}
   */
  get isZeroTransformation() { return null;}
}
/**
 &lt;summary>
   Represents the name and orientation of a View (and named view).
   &lt;para>views can be thought of as cameras.&lt;/para>
   &lt;/summary>
 * @hideconstructor
 */
class ViewInfo {
  /**
   * @description Gets or sets the name of the NamedView.
   * @type {string}
   */
  get name() { return null;}
  /**
   */
  get wallpaperName() { return null;}
  /**
   * @description True if wallpaper (if any) is to be shown in gray scale in this view.
   * @type {bool}
   */
  get showWallpaperInGrayScale() { return null;}
  /**
   * @description True if wallpaper (if any) is to be hidden from this view.
   * @type {bool}
   */
  get wallpaperHidden() { return null;}
  /**
   * @description Gets or sets the Focal blur distance of the active viewport
   * @type {double}
   */
  get focalBlurDistance() { return null;}
  /**
   * @description Gets or sets the Focal blur aperture of the active viewport
   * @type {double}
   */
  get focalBlurAperture() { return null;}
  /**
   * @description Gets or sets the Focal blur jitter of the active viewport
   * @type {double}
   */
  get focalBlurJitter() { return null;}
  /**
   * @description Gets or sets the Focal blur sample count of the active viewport
   * @type {uint}
   */
  get focalBlurSampleCount() { return null;}
}
/**
 &lt;summary>
   Represents a viewing frustum.
   &lt;/summary>
 * @extends CommonObject
 */
class ViewportInfo {
  /**
   * @description Use this function to change projections of valid viewports
     from parallel to perspective.  It will make common additional
     adjustments to the frustum and camera location so the resulting
     views are similar.  The camera direction and target point are
     not be changed.
     If the current projection is parallel and symmetricFrustum,
     FrustumIsLeftRightSymmetric() and FrustumIsTopBottomSymmetric()
     are all equal, then no changes are made and true is returned.
   * @param {bool} symmetricFrustum true if you want the resulting frustum to be symmetric.
   * @returns {bool} true if the operation succeeded; otherwise, false.
   */
  changeToParallelProjection(symmetricFrustum) {  }
  /**
   * @description Use this function to change projections of valid viewports
     from parallel to perspective.  It will make common additional
     adjustments to the frustum and camera location so the resulting
     views are similar.  The camera direction and target point are
     not changed.
     If the current projection is perspective and symmetricFrustum,
     IsFrustumIsLeftRightSymmetric, and IsFrustumIsTopBottomSymmetric
     are all equal, then no changes are made and true is returned.
   * @param {double} targetDistance If RhinoMath.UnsetValue this parameter is ignored.
     Otherwise it must be > 0 and indicates which plane in the current view frustum should be perserved.
   * @param {bool} symmetricFrustum true if you want the resulting frustum to be symmetric.
   * @param {double} lensLength (pass 50.0 when in doubt)
     35 mm lens length to use when changing from parallel
     to perspective projections. If the current projection
     is perspective or lens_length is &lt;= 0.0,
     then this parameter is ignored.
   * @returns {bool} true if the operation succeeded; otherwise, false.
   */
  changeToPerspectiveProjection(targetDistance,symmetricFrustum,lensLength) {  }
  /**
   * @description Changes projections of valid viewports
     to a two point perspective.  It will make common additional
     adjustments to the frustum and camera location and direction
     so the resulting views are similar.
     If the current projection is perspective and
     IsFrustumIsLeftRightSymmetric is true and
     IsFrustumIsTopBottomSymmetric is false, then no changes are
     made and true is returned.
   * @param {double} targetDistance If RhinoMath.UnsetValue this parameter is ignored.  Otherwise
     it must be > 0 and indicates which plane in the current 
     view frustum should be perserved.
   * @param {Array.&lt;x,y,z>} up The locked up direction. Pass Vector3d.Zero if you want to use the world
     axis direction that is closest to the current up direction.
     Pass CameraY() if you want to preserve the current up direction.
   * @param {double} lensLength (pass 50.0 when in doubt)
     35 mm lens length to use when changing from parallel
     to perspective projections. If the current projection
     is perspective or lens_length is &lt;= 0.0,
     then this parameter is ignored.
   * @returns {bool} true if the operation succeeded; otherwise, false.
   */
  changeToTwoPointPerspectiveProjection(targetDistance,up,lensLength) {  }
  /**
   * @description Sets the camera location (position) point.
   * @returns {bool} true if the operation succeeded; otherwise, false.
   */
  setCameraLocation() {  }
  /**
   * @description Sets the direction that the camera faces.
   * @param {Array.&lt;x,y,z>} direction A new direction.
   * @returns {bool} true if the direction was set; otherwise false.
   */
  setCameraDirection(direction) {  }
  /**
   * @description Sets the camera up vector.
   * @param {Array.&lt;x,y,z>} up A new direction.
   * @returns {bool} true if the direction was set; otherwise false.
   */
  setCameraUp(up) {  }
  /**
   * @description Sets the view frustum. If FrustumSymmetryIsLocked() is true
     and left != -right or bottom != -top, then they will be
     adjusted so the resulting frustum is symmetric.
   * @param {double} left A new left value.
   * @param {double} right A new right value.
   * @param {double} bottom A new bottom value.
   * @param {double} top A new top value.
   * @param {double} nearDistance A new near distance value.
   * @param {double} farDistance A new far distance value.
   * @returns {bool} true if operation succeeded; otherwise, false.
   */
  setFrustum(left,right,bottom,top,nearDistance,farDistance) {  }
  /** ... */
  getFrustum() {  }
  /**
   * @description Computes a transform from a coordinate system to another.
   * @param {CoordinateSystem} sourceSystem The coordinate system to map from.
   * @param {CoordinateSystem} destinationSystem The coordinate system to map into.
   * @returns {Transform} The 4x4 transformation matrix (acts on the left).
   */
  getXform(sourceSystem,destinationSystem) {  }
  /**
   * @description Dolly the camera location and so that the view frustum contains
     all of the document objects that can be seen in view.
     If the projection is perspective, the camera angle is not changed.
   * @param {double} border If border > 1.0, then the fustum in enlarged by this factor
     to provide a border around the view.  1.1 works well for
     parallel projections; 0.0 is suggested for perspective projections.
   * @returns {bool} True if successful.
   */
  dollyExtents(border) {  }
  /**
   */
  get isValidCameraFrame() { return null;}
  /**
   */
  get isValidCamer() { return null;}
  /**
   * @description Gets a value that indicates whether the frustum is valid.
   * @type {bool}
   */
  get isValidFrustum() { return null;}
  /**
   * @description Get or set whether this projection is parallel.
   * @type {bool}
   */
  get isParallelProjection() { return null;}
  /**
   * @description Get or set whether this projection is perspective.
   * @type {bool}
   */
  get isPerspectiveProjection() { return null;}
  /**
   * @description Gets a value that indicates whether this projection is a two-point perspective.
   * @type {bool}
   */
  get isTwoPointPerspectiveProjection() { return null;}
  /**
   * @description Gets the camera location (position) point.
   * @type {Array.&lt;x,y,z>}
   */
  get cameraLocation() { return null;}
  /**
   * @description Gets the direction that the camera faces.
   * @type {Array.&lt;x,y,z>}
   */
  get cameraDirection() { return null;}
  /**
   * @description Gets the camera up vector.
   * @type {Array.&lt;x,y,z>}
   */
  get cameraUp() { return null;}
  /**
   * @description Gets the unit "to the right" vector.
   * @type {Array.&lt;x,y,z>}
   */
  get cameraX() { return null;}
  /**
   * @description Gets the unit "up" vector.
   * @type {Array.&lt;x,y,z>}
   */
  get cameraY() { return null;}
  /**
   * @description Gets the unit vector in -CameraDirection.
   * @type {Array.&lt;x,y,z>}
   */
  get cameraZ() { return null;}
  /**
   * @description Get or set the screen port.  and
   * @type {System.Drawing.Rectangle}
   */
  get screenPort() { return null;}
  /**
   * @description Gets the sceen aspect ratio.
     This is width / height.
   * @type {double}
   */
  get screenPortAspect() { return null;}
  /**
   * @description Gets or sets the 1/2 smallest angle. See  for more information.
   * @type {double}
   */
  get cameraAngle() { return null;}
  /**
   * @description This property assumes the camera is horizontal and crop the
     film rather than the image when the aspect of the frustum
     is not 36/24.  (35mm film is 36mm wide and 24mm high.)
     Setting preserves camera location,
     changes the frustum, but maintains the frustum's aspect.
   * @type {double}
   */
  get camera35mmLensLength() { return null;}
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Nov 06 2018 15:52:08 GMT-0800 (Pacific Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>


</body>
</html>
