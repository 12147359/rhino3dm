<!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<title>rhino3dm Sample - Rhino Logo</title>
		<style>
			body {
				color: #808080;
				font-family: Monospace;
				font-size: 13px;
				text-align: center;

				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}

			#controls {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #0080ff;
			}
		</style>
	</head>

	<body>
		<script src="https://threejs.org/build/three.js"></script>
		<script src="OrbitControls.js"></script>
		<script src="rhino3dm.samples.js"></script>

		<div id="container"></div>

		<div id="controls"><button onclick="loadRhinoLogo()">Load Model</button></div>

		<script>
			function meshToLineSegments(mesh, material) {
				verts = mesh.vertices();
				faces = mesh.faces();

				var geometry = new THREE.Geometry();
				for (i = 0; i < faces.count; i++) {
					face = faces.get(i);
					pts = [verts.get(face[0]), verts.get(face[1]), verts.get(face[2]), verts.get(face[3])];
					geometry.vertices.push(
						toVec3(pts[0]), toVec3(pts[1]),
						toVec3(pts[1]), toVec3(pts[2]),
						toVec3(pts[2]), toVec3(pts[3])
					);
					if( face[2]!=face[3] ){
						geometry.vertices.push( toVec3(pts[3]), toVec3(pts[0]) );
					}
				}
				var lines = new THREE.LineSegments( geometry, material );
				return lines;
			}

			function meshToThreejs(mesh, material=null) {
				var geometry = new THREE.BufferGeometry();
				var vertices = mesh.vertices();
				var vertexbuffer = new Float32Array(3 * vertices.count);
				for( var i=0; i<vertices.count; i++) {
					pt = vertices.get(i);
					vertexbuffer[i*3] = pt[0];
					vertexbuffer[i*3+1] = pt[1];
					vertexbuffer[i*3+2] = pt[2];
				}
				// itemSize = 3 because there are 3 values (components) per vertex
				geometry.addAttribute( 'position', new THREE.BufferAttribute( vertexbuffer, 3 ) );

				indices = [];
				var faces = mesh.faces();
				for( var i=0; i<faces.count; i++) {
					face = faces.get(i);
					indices.push(face[0], face[1], face[2]);
					if( face[2] != face[3] ) {
						indices.push(face[2], face[3], face[0]);
					}
				}
				geometry.setIndex(indices);

				var normals = mesh.normals();
				var normalBuffer = new Float32Array(3*normals.count);
				for( var i=0; i<normals.count; i++) {
					pt = normals.get(i);
					normalBuffer[i*3] = pt[0];
					normalBuffer[i*3+1] = pt[1];
					normalBuffer[i*3+2] = pt[1];
				}
				geometry.addAttribute( 'normal', new THREE.BufferAttribute( normalBuffer, 3 ) );
				geometry.addAttribute( 'color', new THREE.BufferAttribute( normalBuffer, 3 ) );

				var material = new THREE.MeshPhongMaterial( {
					color: 0xffffff,
					//flatShading: true,
					//vertexColors: THREE.VertexColors,
					shininess: 0
				} );

				var threemesh = new THREE.Mesh( geometry, material );
				return threemesh;
			}

			function addMeshesToScene(model) {

				for(brepindex=0; brepindex<model.breps.length; brepindex++) {
					var brep = model.breps[brepindex];
					if( brep["meshes"].length > 0 && brep["threejs"]==null){
						var meshes = brep["meshes"];
						brep["threejs"] = [];
						var lineMaterial = new THREE.LineBasicMaterial({color: 0x003333});

						for(meshindex=0; meshindex<meshes.length; meshindex++) {
							mesh = meshes[meshindex]
							mesh.rotate(-1.571, [1,0,0], [0,0,0]);
							var lines = meshToLineSegments(mesh, lineMaterial);
							scene.add( lines );
							var threemesh = meshToThreejs(mesh);
							scene.add( threemesh );

							brep["threejs"].push([lines, threemesh]);
						}
					}
				}
			}

			function loadRhinoLogo() {
				getRhinoLogoMeshes(addMeshesToScene);
			}


			var container, stats;

			var camera, scene, renderer;

			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			var light;
			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 40;

				scene = new THREE.Scene();

				var canvas = document.createElement( 'canvas' );
				canvas.width = 128;
				canvas.height = 128;
				var context = canvas.getContext( '2d' );
				var gradient = context.createLinearGradient( 0, 0, 0, canvas.height);
				gradient.addColorStop( 0.1, 'rgba(0,210,210,1)' );
				gradient.addColorStop( 1, 'rgba(255,255,255,1)' );

				context.fillStyle = gradient;
				context.fillRect( 0, 0, canvas.width, canvas.height );
				scene.background = new THREE.CanvasTexture( canvas );

				light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 0, 0, 1 );
				scene.add( light );

				var light2 = new THREE.DirectionalLight( 0x666666 );
				light2.position.set( 0.2, 0.2, -1 );
				scene.add( light2 );




/*

				var radius = 40;

				var geometry1 = new THREE.IcosahedronBufferGeometry( radius, 1 );

				var count = geometry1.attributes.position.count;
				geometry1.addAttribute( 'color', new THREE.BufferAttribute( new Float32Array( count * 3 ), 3 ) );

				var color = new THREE.Color();
				var positions1 = geometry1.attributes.position;
				var colors1 = geometry1.attributes.color;

				for ( var i = 0; i < count; i ++ ) {
					color.setHSL( ( positions1.getY( i ) / radius + 1 ) / 2, 1.0, 0.5 );
					colors1.setXYZ( i, color.r, color.g, color.b );
				}

				var material = new THREE.MeshPhongMaterial( {
					color: 0xffffff,
					flatShading: true,
					vertexColors: THREE.VertexColors,
					shininess: 0
				} );
*/
				//var wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, transparent: false } );


				//var mesh = new THREE.Mesh( geometry1, material );
				//var wireframe = new THREE.Mesh( geometry1, wireframeMaterial );
				//mesh.add( wireframe );
				//scene.add( mesh );

				renderer = new THREE.WebGLRenderer( { antialias: true } );


				controls = new THREE.OrbitControls( camera, renderer.domElement );
				//controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)
				controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				controls.dampingFactor = 0.25;
				controls.screenSpacePanning = false;
				controls.minDistance = 10;
				controls.maxDistance = 500;
				controls.minPolarAngle = -Infinity;
				controls.maxPolarAngle = Infinity;


				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );


				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function onDocumentMouseMove( event ) {
				mouseX = ( event.clientX - windowHalfX );
				mouseY = ( event.clientY - windowHalfY );
			}

			function animate() {
				requestAnimationFrame( animate );
				controls.update();
				render();
			}

			function render() {
				//camera.position.x += ( mouseX - camera.position.x ) * 0.005;
				//camera.position.y += ( - mouseY - camera.position.y ) * 0.005;
				//light.position.set( camera.position.x, camera.position.y, camera.position.z );

				//camera.lookAt( scene.position );

				renderer.render( scene, camera );
			}
		</script>

		<script async type="text/javascript" src="rhino3dm.js"></script>
	</body>
</html>
